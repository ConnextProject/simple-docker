{
  "language": "Solidity",
  "sources": {
    "contracts/adjudicator/ChallengeRegistry.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"./mixins/MixinChallengeRegistryCore.sol\";\nimport \"./mixins/MixinSetState.sol\";\nimport \"./mixins/MixinProgressState.sol\";\nimport \"./mixins/MixinSetAndProgressState.sol\";\nimport \"./mixins/MixinCancelDispute.sol\";\nimport \"./mixins/MixinSetOutcome.sol\";\n\n\n/// @dev Base contract implementing all logic needed for full-featured App registry\n// solium-disable-next-line lbrace\ncontract ChallengeRegistry is\n  MixinChallengeRegistryCore,\n  MixinSetState,\n  MixinProgressState,\n  MixinSetAndProgressState,\n  MixinCancelDispute,\n  MixinSetOutcome {\n    // solium-disable-next-line no-empty-blocks\n    constructor () public {}\n}\n"
    },
    "contracts/adjudicator/mixins/MixinChallengeRegistryCore.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../libs/LibStateChannelApp.sol\";\nimport \"./MChallengeRegistryCore.sol\";\n\n\n/// @title MixinChallengeRegistryCore\n/// @author Liam Horne - <liam@l4v.io>\n/// @notice Core functionality and utilities for the ChallengeRegistry\ncontract MixinChallengeRegistryCore is MChallengeRegistryCore {\n\n    /// @notice A getter function for the current AppChallenge state\n    /// @param identityHash The unique hash of an `AppIdentity`\n    /// @return A `AppChallenge` object representing the state of the on-chain challenge\n    function getAppChallenge(bytes32 identityHash)\n        external\n        view\n        returns (AppChallenge memory)\n    {\n        return appChallenges[identityHash];\n    }\n\n    /// @notice A getter function for the outcome if one is set\n    /// @param identityHash The unique hash of an `AppIdentity`\n    /// @return A `Transfer.Transaction` object representing the outcome of the channel\n    function getOutcome(bytes32 identityHash)\n        external\n        view\n        returns (bytes memory)\n    {\n        AppChallenge storage challenge = appChallenges[identityHash];\n        require(\n            isOutcomeSet(challenge),\n            \"Outcome hasn't been set yet\"\n        );\n\n        return appOutcomes[identityHash];\n    }\n\n}\n"
    },
    "contracts/adjudicator/libs/LibStateChannelApp.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../../shared/libs/LibChannelCrypto.sol\";\nimport \"./LibDispute.sol\";\n\n/// @title LibStateChannelApp\n/// @author Liam Horne - <liam@l4v.io>\n/// @notice Contains the structures and enums needed when disputing apps\ncontract LibStateChannelApp is LibDispute {\n\n    using LibChannelCrypto for bytes32;\n    using SafeMath for uint256;\n\n    // A minimal structure that uniquely identifies a single instance of an App\n    struct AppIdentity {\n        address multisigAddress;\n        uint256 channelNonce;\n        address[] participants;\n        address appDefinition;\n        uint256 defaultTimeout;\n    }\n\n    // A structure representing the state of a CounterfactualApp instance from the POV of the blockchain\n    // NOTE: AppChallenge is the overall state of a channelized app instance,\n    // appStateHash is the hash of a state specific to the CounterfactualApp (e.g. chess position)\n    struct AppChallenge {\n        ChallengeStatus status;\n        bytes32 appStateHash;\n        uint256 versionNumber;\n        uint256 finalizesAt;\n    }\n\n    /// @dev Checks whether the given timeout has passed\n    /// @param timeout a timeout as block number\n    function hasPassed(\n        uint256 timeout\n    )\n        public\n        view\n        returns (bool)\n    {\n        return timeout <= block.number;\n    }\n\n    /// @dev Checks whether it is still possible to send all-party-signed states\n    /// @param appChallenge the app challenge to check\n    function isDisputable(\n        AppChallenge memory appChallenge\n    )\n        public\n        view\n        returns (bool)\n    {\n        return appChallenge.status == ChallengeStatus.NO_CHALLENGE ||\n            (\n                appChallenge.status == ChallengeStatus.IN_DISPUTE &&\n                !hasPassed(appChallenge.finalizesAt)\n            );\n    }\n\n    /// @dev Checks an outcome for a challenge has been set\n    /// @param appChallenge the app challenge to check\n    function isOutcomeSet(\n        AppChallenge memory appChallenge\n    )\n        public\n        pure\n        returns (bool)\n    {\n        return appChallenge.status == ChallengeStatus.OUTCOME_SET;\n    }\n\n    /// @dev Checks whether it is possible to send actions to progress state\n    /// @param appChallenge the app challenge to check\n    /// @param defaultTimeout the app instance's default timeout\n    function isProgressable(\n        AppChallenge memory appChallenge,\n        uint256 defaultTimeout\n    )\n        public\n        view\n        returns (bool)\n    {\n        return\n            (\n                appChallenge.status == ChallengeStatus.IN_DISPUTE &&\n                hasPassed(appChallenge.finalizesAt) &&\n                !hasPassed(appChallenge.finalizesAt.add(defaultTimeout))\n            ) ||\n            (\n                appChallenge.status == ChallengeStatus.IN_ONCHAIN_PROGRESSION &&\n                !hasPassed(appChallenge.finalizesAt)\n            );\n    }\n\n    /// @dev Checks whether it is possible to cancel a given challenge\n    /// @param appChallenge the app challenge to check\n    /// @param defaultTimeout the app instance's default timeout\n    function isCancellable(\n        AppChallenge memory appChallenge,\n        uint256 defaultTimeout\n    )\n        public\n        view\n        returns (bool)\n    {\n        // Note: we also initially allowed cancelling a dispute during\n        //       the dispute phase but before timeout had expired.\n        //       TODO: does that make sense to add back in?\n        return isProgressable(appChallenge, defaultTimeout);\n    }\n\n    /// @dev Checks whether the state is finalized\n    /// @param appChallenge the app challenge to check\n    /// @param defaultTimeout the app instance's default timeout\n    function isFinalized(\n        AppChallenge memory appChallenge,\n        uint256 defaultTimeout\n    )\n        public\n        view\n        returns (bool)\n    {\n        return (\n          (\n              appChallenge.status == ChallengeStatus.IN_DISPUTE &&\n              hasPassed(appChallenge.finalizesAt.add(defaultTimeout))\n          ) ||\n          (\n              appChallenge.status == ChallengeStatus.IN_ONCHAIN_PROGRESSION &&\n              hasPassed(appChallenge.finalizesAt)\n          ) ||\n          (\n              appChallenge.status == ChallengeStatus.EXPLICITLY_FINALIZED\n          )\n        );\n    }\n\n    /// @dev Verifies signatures given the signer addresses\n    /// @param signatures message `txHash` signature\n    /// @param txHash operation ethereum signed message hash\n    /// @param signers addresses of all signers in order\n    function verifySignatures(\n        bytes[] memory signatures,\n        bytes32 txHash,\n        address[] memory signers\n    )\n        public\n        pure\n        returns (bool)\n    {\n        require(\n            signers.length == signatures.length,\n            \"Signers and signatures should be of equal length\"\n        );\n        for (uint256 i = 0; i < signers.length; i++) {\n            require(\n                signers[i] == txHash.verifyChannelMessage(signatures[i]),\n                \"Invalid signature\"\n            );\n        }\n        return true;\n    }\n\n}\n"
    },
    "@openzeppelin/contracts/math/SafeMath.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Wrappers over Solidity's arithmetic operations with added overflow\n * checks.\n *\n * Arithmetic operations in Solidity wrap on overflow. This can easily result\n * in bugs, because programmers usually assume that an overflow raises an\n * error, which is the standard behavior in high level programming languages.\n * `SafeMath` restores this intuition by reverting the transaction when an\n * operation overflows.\n *\n * Using this library instead of the unchecked operations eliminates an entire\n * class of bugs, so it's recommended to use it always.\n */\nlibrary SafeMath {\n    /**\n     * @dev Returns the addition of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `+` operator.\n     *\n     * Requirements:\n     * - Addition cannot overflow.\n     */\n    function add(uint256 a, uint256 b) internal pure returns (uint256) {\n        uint256 c = a + b;\n        require(c >= a, \"SafeMath: addition overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b) internal pure returns (uint256) {\n        return sub(a, b, \"SafeMath: subtraction overflow\");\n    }\n\n    /**\n     * @dev Returns the subtraction of two unsigned integers, reverting with custom message on\n     * overflow (when the result is negative).\n     *\n     * Counterpart to Solidity's `-` operator.\n     *\n     * Requirements:\n     * - Subtraction cannot overflow.\n     */\n    function sub(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b <= a, errorMessage);\n        uint256 c = a - b;\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the multiplication of two unsigned integers, reverting on\n     * overflow.\n     *\n     * Counterpart to Solidity's `*` operator.\n     *\n     * Requirements:\n     * - Multiplication cannot overflow.\n     */\n    function mul(uint256 a, uint256 b) internal pure returns (uint256) {\n        // Gas optimization: this is cheaper than requiring 'a' not being zero, but the\n        // benefit is lost if 'b' is also tested.\n        // See: https://github.com/OpenZeppelin/openzeppelin-contracts/pull/522\n        if (a == 0) {\n            return 0;\n        }\n\n        uint256 c = a * b;\n        require(c / a == b, \"SafeMath: multiplication overflow\");\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b) internal pure returns (uint256) {\n        return div(a, b, \"SafeMath: division by zero\");\n    }\n\n    /**\n     * @dev Returns the integer division of two unsigned integers. Reverts with custom message on\n     * division by zero. The result is rounded towards zero.\n     *\n     * Counterpart to Solidity's `/` operator. Note: this function uses a\n     * `revert` opcode (which leaves remaining gas untouched) while Solidity\n     * uses an invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function div(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        // Solidity only automatically asserts when dividing by 0\n        require(b > 0, errorMessage);\n        uint256 c = a / b;\n        // assert(a == b * c + a % b); // There is no case in which this doesn't hold\n\n        return c;\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b) internal pure returns (uint256) {\n        return mod(a, b, \"SafeMath: modulo by zero\");\n    }\n\n    /**\n     * @dev Returns the remainder of dividing two unsigned integers. (unsigned integer modulo),\n     * Reverts with custom message when dividing by zero.\n     *\n     * Counterpart to Solidity's `%` operator. This function uses a `revert`\n     * opcode (which leaves remaining gas untouched) while Solidity uses an\n     * invalid opcode to revert (consuming all remaining gas).\n     *\n     * Requirements:\n     * - The divisor cannot be zero.\n     */\n    function mod(uint256 a, uint256 b, string memory errorMessage) internal pure returns (uint256) {\n        require(b != 0, errorMessage);\n        return a % b;\n    }\n}\n"
    },
    "contracts/shared/libs/LibChannelCrypto.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental ABIEncoderV2;\n\nimport \"@openzeppelin/contracts/cryptography/ECDSA.sol\";\n\nlibrary LibChannelCrypto {\n    function verifyChannelMessage(bytes32 hash, bytes memory signature) internal pure returns (address) {\n      bytes32 digest = toChannelSignedMessage(hash);\n      return ECDSA.recover(digest, signature);\n    }\n\n    function toChannelSignedMessage(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x15Indra Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "@openzeppelin/contracts/cryptography/ECDSA.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Elliptic Curve Digital Signature Algorithm (ECDSA) operations.\n *\n * These functions can be used to verify that a message was signed by the holder\n * of the private keys of a given address.\n */\nlibrary ECDSA {\n    /**\n     * @dev Returns the address that signed a hashed message (`hash`) with\n     * `signature`. This address can then be used for verification purposes.\n     *\n     * The `ecrecover` EVM opcode allows for malleable (non-unique) signatures:\n     * this function rejects them by requiring the `s` value to be in the lower\n     * half order, and the `v` value to be either 27 or 28.\n     *\n     * IMPORTANT: `hash` _must_ be the result of a hash operation for the\n     * verification to be secure: it is possible to craft signatures that\n     * recover to arbitrary addresses for non-hashed data. A safe way to ensure\n     * this is by receiving a hash of the original message (which may otherwise\n     * be too long), and then calling {toEthSignedMessageHash} on it.\n     */\n    function recover(bytes32 hash, bytes memory signature) internal pure returns (address) {\n        // Check the signature length\n        if (signature.length != 65) {\n            revert(\"ECDSA: invalid signature length\");\n        }\n\n        // Divide the signature in r, s and v variables\n        bytes32 r;\n        bytes32 s;\n        uint8 v;\n\n        // ecrecover takes the signature parameters, and the only way to get them\n        // currently is to use assembly.\n        // solhint-disable-next-line no-inline-assembly\n        assembly {\n            r := mload(add(signature, 0x20))\n            s := mload(add(signature, 0x40))\n            v := byte(0, mload(add(signature, 0x60)))\n        }\n\n        // EIP-2 still allows signature malleability for ecrecover(). Remove this possibility and make the signature\n        // unique. Appendix F in the Ethereum Yellow paper (https://ethereum.github.io/yellowpaper/paper.pdf), defines\n        // the valid range for s in (281): 0 < s < secp256k1n ÷ 2 + 1, and for v in (282): v ∈ {27, 28}. Most\n        // signatures from current libraries generate a unique signature with an s-value in the lower half order.\n        //\n        // If your library generates malleable signatures, such as s-values in the upper range, calculate a new s-value\n        // with 0xFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFEBAAEDCE6AF48A03BBFD25E8CD0364141 - s1 and flip v from 27 to 28 or\n        // vice versa. If your library also generates signatures with 0/1 for v instead 27/28, add 27 to v to accept\n        // these malleable signatures as well.\n        if (uint256(s) > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF5D576E7357A4501DDFE92F46681B20A0) {\n            revert(\"ECDSA: invalid signature 's' value\");\n        }\n\n        if (v != 27 && v != 28) {\n            revert(\"ECDSA: invalid signature 'v' value\");\n        }\n\n        // If the signature is valid (and not malleable), return the signer address\n        address signer = ecrecover(hash, v, r, s);\n        require(signer != address(0), \"ECDSA: invalid signature\");\n\n        return signer;\n    }\n\n    /**\n     * @dev Returns an Ethereum Signed Message, created from a `hash`. This\n     * replicates the behavior of the\n     * https://github.com/ethereum/wiki/wiki/JSON-RPC#eth_sign[`eth_sign`]\n     * JSON-RPC method.\n     *\n     * See {recover}.\n     */\n    function toEthSignedMessageHash(bytes32 hash) internal pure returns (bytes32) {\n        // 32 is the length in bytes of hash,\n        // enforced by the type signature above\n        return keccak256(abi.encodePacked(\"\\x19Ethereum Signed Message:\\n32\", hash));\n    }\n}\n"
    },
    "contracts/adjudicator/libs/LibDispute.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental ABIEncoderV2;\n\n\n/// @title LibDispute\n/// @notice Contains the structures and enums needed or generally useful in disputes\ncontract LibDispute {\n\n    // The status of a challenge in the ChallengeRegistry\n    enum ChallengeStatus {\n        NO_CHALLENGE,\n        IN_DISPUTE,\n        IN_ONCHAIN_PROGRESSION,\n        EXPLICITLY_FINALIZED,\n        OUTCOME_SET\n    }\n\n    // State hash with version number and timeout, signed by all parties\n    struct SignedAppChallengeUpdate {\n        bytes32 appStateHash;\n        uint256 versionNumber;\n        uint256 timeout;\n        bytes[] signatures;\n    }\n\n    // Used to cancel a challenge. Inc. current onchain state hash,\n    // challenge status, and signatures on this\n    struct SignedCancelDisputeRequest {\n        uint256 versionNumber;\n        bytes[] signatures;\n    }\n\n    // Event emitted when state is progressed via a unilateral action\n    event StateProgressed (\n      bytes32 identityHash,\n      bytes action,\n      uint256 versionNumber,\n      uint256 timeout,\n      address turnTaker,\n      bytes signature\n    );\n\n    // Event emitted when the challenge is updated\n    event ChallengeUpdated (\n      bytes32 identityHash,\n      ChallengeStatus status,\n      bytes32 appStateHash,\n      uint256 versionNumber,\n      uint256 finalizesAt\n    );\n}\n"
    },
    "contracts/adjudicator/mixins/MChallengeRegistryCore.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../../shared/libs/LibCommitment.sol\";\nimport \"../libs/LibStateChannelApp.sol\";\nimport \"../libs/LibAppCaller.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\ncontract MChallengeRegistryCore is LibCommitment, LibStateChannelApp, LibAppCaller {\n\n    using SafeMath for uint256;\n\n    // A mapping of appIdentityHash to AppChallenge structs which represents\n    // the current on-chain status of some particular application's state.\n    mapping (bytes32 => AppChallenge) public appChallenges;\n\n    // A mapping of appIdentityHash to outcomes\n    mapping (bytes32 => bytes) public appOutcomes;\n\n    /// @notice Compute a hash of an application's state\n    /// @param appState The ABI encoded state\n    /// @return A bytes32 hash of the state\n    function appStateToHash(\n        bytes memory appState\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(appState);\n    }\n\n    /// @notice Compute a unique hash for a single instance of an App\n    /// @param appIdentity An `AppIdentity` struct that encodes all unique info for an App\n    /// @return A bytes32 hash of the AppIdentity\n    function appIdentityToHash(\n        AppIdentity memory appIdentity\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encodePacked(\n                appIdentity.multisigAddress,\n                appIdentity.channelNonce,\n                keccak256(abi.encodePacked(appIdentity.participants)),\n                appIdentity.appDefinition,\n                appIdentity.defaultTimeout\n            )\n        );\n    }\n\n    /// @notice Compute a unique hash for the state of a channelized app instance\n    /// @param identityHash The unique hash of an `AppIdentity`\n    /// @param appStateHash The hash of the app state to be signed\n    /// @param versionNumber The versionNumber corresponding to the version of the state\n    /// @param timeout A dynamic timeout value representing the timeout for this state\n    /// @return A bytes32 hash of the RLP encoded arguments\n    function computeAppChallengeHash(\n        bytes32 identityHash,\n        bytes32 appStateHash,\n        uint256 versionNumber,\n        uint256 timeout\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encodePacked(\n                uint8(CommitmentTarget.SET_STATE),\n                identityHash,\n                appStateHash,\n                versionNumber,\n                timeout\n            )\n        );\n    }\n\n    /// @notice Compute a unique hash for the state of a channelized app instance\n    /// @param identityHash The unique hash of an `AppIdentity`\n    /// @param versionNumber The versionNumber corresponding to the version of the state\n    /// @return A bytes32 hash of the RLP encoded arguments\n    function computeCancelDisputeHash(\n        bytes32 identityHash,\n        uint256 versionNumber\n    )\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encodePacked(\n                uint8(CommitmentTarget.CANCEL_DISPUTE),\n                identityHash,\n                versionNumber\n            )\n        );\n    }\n\n    function correctKeysSignedAppChallengeUpdate(\n        bytes32 identityHash,\n        address[] memory participants,\n        SignedAppChallengeUpdate memory req\n    )\n        public\n        pure\n        returns (bool)\n    {\n        bytes32 digest = computeAppChallengeHash(\n            identityHash,\n            req.appStateHash,\n            req.versionNumber,\n            req.timeout\n        );\n\n        return verifySignatures(\n            req.signatures,\n            digest,\n            participants\n        );\n    }\n\n}\n"
    },
    "contracts/shared/libs/LibCommitment.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental ABIEncoderV2;\n\n\n/// @title LibCommitment\n/// @notice Contains stuff that's useful for commitments\ncontract LibCommitment {\n\n    // An ID for each commitment type\n    enum CommitmentTarget {\n        MULTISIG,\n        SET_STATE,\n        CANCEL_DISPUTE\n    }\n\n}\n"
    },
    "contracts/adjudicator/libs/LibAppCaller.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../interfaces/CounterfactualApp.sol\";\n\n\n/// @title LibAppCaller\n/// @author Liam Horne - <liam@l4v.io>\n/// @notice A library for the ChallengeRegistry to make staticcalls to Apps\ncontract LibAppCaller {\n\n    /// @notice A helper method to check if the state of an application is terminal or not\n    /// @param appDefinition An address of an app definition to call\n    /// @param appState The ABI encoded version of some application state\n    /// @return A boolean indicating if the application state is terminal or not\n    function isStateTerminal(\n        address appDefinition,\n        bytes memory appState\n    )\n        internal\n        view\n        returns (bool)\n    {\n        return CounterfactualApp(appDefinition).isStateTerminal(appState);\n    }\n\n    /// @notice A helper method to get the turn taker for an app\n    /// @param appDefinition An address of an app definition to call\n    /// @param appState The ABI encoded version of some application state\n    /// @return An address representing the turn taker in the `participants`\n    function getTurnTaker(\n        address appDefinition,\n        address[] memory participants,\n        bytes memory appState\n    )\n        internal\n        view\n        returns (address)\n    {\n        return CounterfactualApp(appDefinition)\n            .getTurnTaker(appState, participants);\n    }\n\n    /// @notice Execute the application's applyAction function to compute new state\n    /// @param appDefinition An address of an app definition to call\n    /// @param appState The ABI encoded version of some application state\n    /// @param action The ABI encoded version of some application action\n    /// @return A bytes array of the ABI encoded newly computed application state\n    function applyAction(\n        address appDefinition,\n        bytes memory appState,\n        bytes memory action\n    )\n        internal\n        view\n        returns (bytes memory)\n    {\n        return CounterfactualApp(appDefinition).applyAction(appState, action);\n    }\n\n    /// @notice Execute the application's computeOutcome function to compute an outcome\n    /// @param appDefinition An address of an app definition to call\n    /// @param appState The ABI encoded version of some application state\n    function computeOutcome(\n        address appDefinition,\n        bytes memory appState\n    )\n        internal\n        view\n        returns (bytes memory)\n    {\n        return CounterfactualApp(appDefinition).computeOutcome(appState);\n    }\n\n}\n"
    },
    "contracts/adjudicator/interfaces/CounterfactualApp.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"./CounterfactualAppInterface.sol\";\n\n\ncontract CounterfactualApp is CounterfactualAppInterface {\n\n    function isStateTerminal(bytes calldata)\n        override\n        virtual\n        external\n        view\n        returns (bool)\n    {\n        revert(\"The isStateTerminal method has no implementation for this App\");\n    }\n\n    function getTurnTaker(bytes calldata, address[] calldata)\n        override\n        virtual\n        external\n        view\n        returns (address)\n    {\n        revert(\"The getTurnTaker method has no implementation for this App\");\n    }\n\n    function applyAction(bytes calldata, bytes calldata)\n        override\n        virtual\n        external\n        view\n        returns (bytes memory)\n    {\n        revert(\"The applyAction method has no implementation for this App\");\n    }\n\n    function computeOutcome(bytes calldata)\n        override\n        virtual\n        external\n        view\n        returns (bytes memory)\n    {\n        revert(\"The computeOutcome method has no implementation for this App\");\n    }\n\n}\n"
    },
    "contracts/adjudicator/interfaces/CounterfactualAppInterface.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\n\ninterface CounterfactualAppInterface {\n\n    function isStateTerminal(bytes calldata)\n        external\n        view\n        returns (bool);\n\n    function getTurnTaker(bytes calldata, address[] calldata)\n        external\n        view\n        returns (address);\n\n    function applyAction(bytes calldata, bytes calldata)\n        external\n        view\n        returns (bytes memory);\n\n    function computeOutcome(bytes calldata)\n        external\n        view\n        returns (bytes memory);\n\n}\n"
    },
    "contracts/adjudicator/mixins/MixinSetState.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../libs/LibStateChannelApp.sol\";\nimport \"./MChallengeRegistryCore.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\ncontract MixinSetState is LibStateChannelApp, MChallengeRegistryCore {\n\n    using SafeMath for uint256;\n\n    /// @notice Set the instance state/AppChallenge to a given value.\n    /// This value must have been signed off by all parties to the channel, that is,\n    /// this must be called with the correct msg.sender (the state deposit holder)\n    /// or signatures must be provided.\n    /// @param appIdentity an AppIdentity struct with all information encoded within\n    ///        it to represent which particular app is having state submitted\n    /// @param req An object containing the update to be applied to the\n    ///        applications state including the signatures of the users needed\n    /// @dev This function is only callable when the state channel is not in challenge\n    function setState(\n        AppIdentity memory appIdentity,\n        SignedAppChallengeUpdate memory req\n    )\n        public\n    {\n        bytes32 identityHash = appIdentityToHash(appIdentity);\n        AppChallenge storage challenge = appChallenges[identityHash];\n\n        require(\n            isDisputable(challenge),\n            \"setState was called on an app that cannot be disputed anymore\"\n        );\n\n        require(\n            correctKeysSignedAppChallengeUpdate(\n                identityHash,\n                appIdentity.participants,\n                req\n            ),\n            \"Call to setState included incorrectly signed state update\"\n        );\n\n        require(\n            req.versionNumber > challenge.versionNumber,\n            \"setState was called with outdated state\"\n        );\n\n        // Update challenge\n        challenge.status = ChallengeStatus.IN_DISPUTE;\n        challenge.appStateHash = req.appStateHash;\n        challenge.versionNumber = req.versionNumber;\n        challenge.finalizesAt = block.number.add(req.timeout);\n\n        emit ChallengeUpdated(\n            identityHash,\n            challenge.status,\n            challenge.appStateHash,\n            challenge.versionNumber,\n            challenge.finalizesAt\n        );\n    }\n\n}\n"
    },
    "contracts/adjudicator/mixins/MixinProgressState.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../libs/LibStateChannelApp.sol\";\nimport \"./MChallengeRegistryCore.sol\";\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\n\n\ncontract MixinProgressState is LibStateChannelApp, MChallengeRegistryCore {\n\n    using SafeMath for uint256;\n\n    /// @notice Progress state with a unilateral action on the stored state\n    /// @param appIdentity An AppIdentity object\n    /// @param req A signed app challenge update that contains the resulting state,\n    ///        i.e. the state that results from applying the given action to the stored state\n    /// @param oldAppState The ABI encoded state that corresponds to the stored hash\n    /// @param action The abi-encoded action to be taken on oldAppState\n    function progressState(\n        AppIdentity memory appIdentity,\n        SignedAppChallengeUpdate memory req,\n        bytes memory oldAppState,\n        bytes memory action\n    )\n        public\n    {\n        bytes32 identityHash = appIdentityToHash(appIdentity);\n        AppChallenge storage challenge = appChallenges[identityHash];\n\n        require(\n            isProgressable(challenge, appIdentity.defaultTimeout),\n            \"progressState called on app not in a progressable state\"\n        );\n\n        bytes32 oldAppStateHash = appStateToHash(oldAppState);\n\n        require(\n            oldAppStateHash == challenge.appStateHash,\n            \"progressState called with oldAppState that does not match stored challenge\"\n        );\n\n        address turnTaker = getTurnTaker(\n            appIdentity.appDefinition,\n            appIdentity.participants,\n            oldAppState\n        );\n\n        // Build an array that contains only the turn-taker\n        address[] memory signers = new address[](1);\n        signers[0] = turnTaker;\n\n        require(\n            correctKeysSignedAppChallengeUpdate(\n                identityHash,\n                signers,\n                req\n            ),\n            \"Call to progressState included incorrectly signed state update\"\n        );\n\n        // This should throw an error if reverts\n        bytes memory newAppState = applyAction(\n            appIdentity.appDefinition,\n            oldAppState,\n            action\n        );\n\n        bytes32 newAppStateHash = appStateToHash(newAppState);\n\n        require(\n            newAppStateHash == req.appStateHash,\n            \"progressState: applying action to old state does not match new state\"\n        );\n\n        require(\n            req.versionNumber == challenge.versionNumber.add(1),\n            \"progressState: versionNumber of new state is not that of stored state plus 1\"\n        );\n\n        // Update challenge\n        challenge.status = ChallengeStatus.IN_ONCHAIN_PROGRESSION;\n        challenge.appStateHash = newAppStateHash;\n        challenge.versionNumber = req.versionNumber;\n        challenge.finalizesAt = block.number.add(appIdentity.defaultTimeout);\n\n        // Check whether state is terminal, for immediate finalization (could be optional)\n        if (isStateTerminal(appIdentity.appDefinition, newAppState)) {\n            challenge.status = ChallengeStatus.EXPLICITLY_FINALIZED;\n        }\n\n        emit StateProgressed(\n            identityHash,\n            action,\n            req.versionNumber,\n            req.timeout,\n            turnTaker,\n            req.signatures[0]\n        );\n\n        emit ChallengeUpdated(\n            identityHash,\n            challenge.status,\n            challenge.appStateHash,\n            challenge.versionNumber,\n            challenge.finalizesAt\n        );\n    }\n\n}\n"
    },
    "contracts/adjudicator/mixins/MixinSetAndProgressState.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../libs/LibDispute.sol\";\nimport \"./MixinSetState.sol\";\nimport \"./MixinProgressState.sol\";\n\n\ncontract MixinSetAndProgressState is LibDispute, MixinSetState, MixinProgressState {\n\n    /// @notice Create a challenge regarding the latest signed state and immediately after,\n    /// performs a unilateral action to update it; the latest signed state must have timeout 0\n    /// @param appIdentity An AppIdentity object\n    /// @param req1 A signed app challenge update that contains the hash of the latest state\n    /// that has been signed by all parties; the timeout must be 0\n    /// @param req2 A signed app challenge update that contains the state that results\n    /// from applying the action to appState\n    /// @param appState The full state whose hash is the state hash in req1\n    /// @param action The abi-encoded action to be taken on appState\n    function setAndProgressState(\n        AppIdentity memory appIdentity,\n        SignedAppChallengeUpdate memory req1,\n        SignedAppChallengeUpdate memory req2,\n        bytes memory appState,\n        bytes memory action\n    )\n        public\n    {\n        setState(\n            appIdentity,\n            req1\n        );\n\n        progressState(\n            appIdentity,\n            req2,\n            appState,\n            action\n        );\n\n        // Maybe TODO:\n        // This can be made slightly more efficient by doing _directly_\n        // what these two functions do and leaving out unnecessary parts\n        // like the intermediate storing of the challenge (before the\n        // action has been applied to it) and skipping tests we know\n        // must be true.\n        // For now, this is the easiest and most convenient way, though.\n    }\n\n}\n"
    },
    "contracts/adjudicator/mixins/MixinCancelDispute.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../libs/LibStateChannelApp.sol\";\nimport \"./MChallengeRegistryCore.sol\";\n\n\ncontract MixinCancelDispute is LibStateChannelApp, MChallengeRegistryCore {\n\n    /// @notice Unanimously agree to cancel a challenge\n    /// @param appIdentity an AppIdentity object pointing to the app being cancelled\n    /// @param req Cancel request, includes signatures on app state hash + current challenge status\n    /// @dev Note this function is only callable when the application has an open + progressable challenge\n    function cancelDispute(\n        AppIdentity memory appIdentity,\n        SignedCancelDisputeRequest memory req\n    )\n        // TODO: Uncomment when ABIEncoderV2 supports `external`\n        //       ref: https://github.com/ethereum/solidity/issues/3199\n        // external\n        public\n    {\n        bytes32 identityHash = appIdentityToHash(appIdentity);\n        AppChallenge storage challenge = appChallenges[identityHash];\n\n        require(\n            isCancellable(challenge, appIdentity.defaultTimeout),\n            \"cancelDispute called on challenge that cannot be cancelled\"\n        );\n\n        require(\n            correctKeysSignedCancelChallengeRequest(\n                identityHash,\n                appIdentity.participants,\n                req\n            ),\n            \"Call to cancelDispute included incorrectly signed request\"\n        );\n\n        require(\n            req.versionNumber == challenge.versionNumber,\n            \"cancelDispute was called with wrong version number\"\n        );\n\n        // Clear challenge\n        challenge.status = ChallengeStatus.NO_CHALLENGE;\n        challenge.appStateHash = 0;\n        challenge.versionNumber = 0;\n        challenge.finalizesAt = 0;\n\n        emit ChallengeUpdated(\n            identityHash,\n            challenge.status,\n            challenge.appStateHash,\n            challenge.versionNumber,\n            challenge.finalizesAt\n        );\n    }\n\n    function correctKeysSignedCancelChallengeRequest(\n        bytes32 identityHash,\n        address[] memory participants,\n        SignedCancelDisputeRequest memory req\n    )\n        private\n        pure\n        returns (bool)\n    {\n        bytes32 digest = computeCancelDisputeHash(\n            identityHash,\n            req.versionNumber\n        );\n\n        return verifySignatures(\n            req.signatures,\n            digest,\n            participants\n        );\n    }\n\n}\n"
    },
    "contracts/adjudicator/mixins/MixinSetOutcome.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../libs/LibStateChannelApp.sol\";\nimport \"../libs/LibAppCaller.sol\";\nimport \"./MChallengeRegistryCore.sol\";\n\n\ncontract MixinSetOutcome is LibStateChannelApp, LibAppCaller, MChallengeRegistryCore {\n\n    /// @notice Fetch and store the outcome of a state channel application\n    /// @param appIdentity An AppIdentity pointing to the app having the outcome set\n    /// @param finalState The ABI encoded version of the finalized application state\n    /// @dev Note this function is only callable when the application has been finalized\n    function setOutcome(\n        AppIdentity memory appIdentity,\n        bytes memory finalState\n    )\n        public\n    {\n        bytes32 identityHash = appIdentityToHash(appIdentity);\n\n        AppChallenge storage challenge = appChallenges[identityHash];\n\n        require(\n            isFinalized(challenge, appIdentity.defaultTimeout),\n            \"setOutcome can only be called after a challenge has been finalized\"\n        );\n\n        require(\n            !isOutcomeSet(challenge),\n            \"setOutcome called on challenge with outcome already set\"\n        );\n\n        require(\n            keccak256(finalState) == challenge.appStateHash,\n            \"setOutcome called with incorrect witness data of finalState\"\n        );\n\n        appOutcomes[identityHash] = LibAppCaller.computeOutcome(\n            appIdentity.appDefinition,\n            finalState\n        );\n        challenge.status = ChallengeStatus.OUTCOME_SET;\n\n        emit ChallengeUpdated(\n            identityHash,\n            challenge.status,\n            challenge.appStateHash,\n            challenge.versionNumber,\n            challenge.finalizesAt\n        );\n    }\n\n}\n"
    },
    "contracts/adjudicator/test-fixtures/AppApplyActionFails.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"./AppWithAction.sol\";\n\n\n/*\n * App with a counter\n * Only participants[1] is allowed to increment it. Apply action will always throw\n */\ncontract AppApplyActionFails is AppWithAction {\n\n    function applyAction(\n        bytes calldata /* encodedState */,\n        bytes calldata /* encodedAction */\n    )\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        revert(\"applyAction fails for this app\");\n    }\n\n}\n"
    },
    "contracts/adjudicator/test-fixtures/AppWithAction.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../interfaces/CounterfactualApp.sol\";\n\n\n/*\n * App with a counter\n * Only participants[1] is allowed to increment it\n */\ncontract AppWithAction is CounterfactualApp {\n\n    enum TwoPartyFixedOutcome {\n        SEND_TO_ADDR_ONE,\n        SEND_TO_ADDR_TWO,\n        SPLIT_AND_SEND_TO_BOTH_ADDRS\n    }\n\n    enum ActionType { SUBMIT_COUNTER_INCREMENT, ACCEPT_INCREMENT }\n\n    struct State {\n        uint256 counter;\n    }\n\n    struct Action {\n        ActionType actionType;\n        uint256 increment;\n    }\n\n    /**\n     * The 0th signer is allowed to make one nonzero increment at turnNum = 0,\n     * after which time the 1st signer may finalize the outcome.\n     */\n    function getTurnTaker(\n        bytes calldata encodedState,\n        address[] calldata participants\n    )\n        override\n        external\n        view\n        returns (address)\n    {\n        State memory state = abi.decode(encodedState, (State));\n        return participants[state.counter > 0 ? 0 : 1];\n    }\n\n    function computeOutcome(bytes calldata)\n        override\n        virtual\n        external\n        view\n        returns (bytes memory)\n    {\n        return abi.encode(TwoPartyFixedOutcome.SEND_TO_ADDR_ONE);\n    }\n\n    function applyAction(\n        bytes calldata encodedState,\n        bytes calldata encodedAction\n    )\n        override\n        virtual\n        external\n        view\n        returns (bytes memory ret)\n    {\n        State memory state = abi.decode(encodedState, (State));\n        Action memory action = abi.decode(encodedAction, (Action));\n\n        if (action.actionType == ActionType.SUBMIT_COUNTER_INCREMENT) {\n            require(action.increment > 0, \"Increment must be nonzero\");\n            state.counter += action.increment;\n        } else if (action.actionType != ActionType.ACCEPT_INCREMENT) {\n            revert(\"Unknown actionType\");\n        }\n\n        return abi.encode(state);\n    }\n\n    function isStateTerminal(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bool)\n    {\n        State memory state = abi.decode(encodedState, (State));\n        return state.counter > 5;\n    }\n\n}\n"
    },
    "contracts/adjudicator/test-fixtures/AppComputeOutcomeFails.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"./AppWithAction.sol\";\n\n\n/*\n * App with a counter\n * Only participants[1] is allowed to increment it\n */\ncontract AppComputeOutcomeFails is AppWithAction {\n\n    function computeOutcome(bytes calldata)\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        revert(\"computeOutcome always fails for this app\");\n    }\n}\n"
    },
    "contracts/apps/HashLockTransferApp.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../adjudicator/interfaces/CounterfactualApp.sol\";\nimport \"../funding/libs/LibOutcome.sol\";\n\n\n/// @title Lightning HTLC Transfer App\n/// @notice This contract allows users to claim a payment locked in\n///         the application if they provide a preImage and expiry\n///         that corresponds to a lightning htlc\ncontract HashLockTransferApp is CounterfactualApp {\n\n    /**\n    * This app can also not be used to send _multiple_ hashlocked payments,\n    * only one can be redeemed with the preImage.\n    */\n    struct AppState {\n        LibOutcome.CoinTransfer[2] coinTransfers;\n        bytes32 lockHash;\n        bytes32 preImage;\n        uint256 expiry;\n        bool finalized;\n    }\n\n    struct Action {\n        bytes32 preImage;\n    }\n\n    function applyAction(\n        bytes calldata encodedState,\n        bytes calldata encodedAction\n    )\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n        Action memory action = abi.decode(encodedAction, (Action));\n        bytes32 generatedHash = sha256(abi.encode(action.preImage));\n\n        require(!state.finalized, \"Cannot take action on finalized state\");\n        require(block.number < state.expiry, \"Cannot take action if expiry is expired\");\n        require(state.lockHash == generatedHash, \"Hash generated from preimage does not match hash in state\");\n\n        state.coinTransfers[1].amount = state.coinTransfers[0].amount;\n        state.coinTransfers[0].amount = 0;\n        state.preImage = action.preImage;\n        state.finalized = true;\n\n        return abi.encode(state);\n    }\n\n    function computeOutcome(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n\n        // If payment hasn't been unlocked, require that the expiry is expired\n        if (!state.finalized) {\n            require(block.number >= state.expiry, \"Cannot revert payment if expiry is unexpired\");\n        }\n\n        return abi.encode(state.coinTransfers);\n    }\n\n    function getTurnTaker(\n        bytes calldata /* encodedState */,\n        address[] calldata participants\n    )\n        override\n        external\n        view\n        returns (address)\n    {\n        return participants[1]; // receiver should always be indexed at [1]\n    }\n\n    function isStateTerminal(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bool)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n        return state.finalized;\n    }\n}\n"
    },
    "contracts/funding/libs/LibOutcome.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\n\nlibrary LibOutcome {\n\n    struct CoinTransfer {\n        address payable to;\n        uint256 amount;\n    }\n\n    enum TwoPartyFixedOutcome {\n        SEND_TO_ADDR_ONE,\n        SEND_TO_ADDR_TWO,\n        SPLIT_AND_SEND_TO_BOTH_ADDRS\n    }\n\n}\n"
    },
    "contracts/apps/HighRollerApp.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../adjudicator/interfaces/CounterfactualApp.sol\";\nimport \"../funding/libs/LibOutcome.sol\";\n\n\n/// @title High Roller App\n/// @notice This contract allows the playing of a dice rolling game.\n///         Two players take turns rolling two dice each.\n///         The winner is the player whose sum of dice outcomes is highest.\n/// @dev This contract is an example of a dApp built to run on\n///      the CounterFactual framework\ncontract HighRollerApp is CounterfactualApp {\n\n    enum ActionType {\n        COMMIT_TO_HASH,\n        COMMIT_TO_NUM,\n        REVEAL_NUM\n    }\n\n    enum Stage {\n        WAITING_FOR_P1_COMMITMENT,\n        P1_COMMITTED_TO_HASH,\n        P2_COMMITTED_TO_NUM,\n        P1_REVEALED_NUM,\n        P1_TRIED_TO_SUBMIT_ZERO\n    }\n\n    enum Player {\n        FIRST,\n        SECOND\n    }\n\n    struct AppState {\n        Stage stage;\n        bytes32 salt;\n        bytes32 commitHash;\n        uint256 playerFirstNumber;\n        uint256 playerSecondNumber;\n        uint256 versionNumber; // NOTE: This field is mandatory, do not modify!\n    }\n\n    struct Action {\n        ActionType actionType;\n        uint256 number;\n        bytes32 actionHash;\n    }\n\n    function isStateTerminal(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bool)\n    {\n        AppState memory appState = abi.decode(encodedState, (AppState));\n        return (\n            appState.stage == Stage.P1_REVEALED_NUM ||\n            appState.stage == Stage.P1_TRIED_TO_SUBMIT_ZERO\n        );\n    }\n\n    // NOTE: Function is being deprecated soon, do not modify!\n    function getTurnTaker(\n        bytes calldata encodedState,\n        address[] calldata participants\n    )\n        override\n        external\n        view\n        returns (address)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n        return participants[state.versionNumber % 2];\n    }\n\n    function applyAction(\n        bytes calldata encodedState,\n        bytes calldata encodedAction\n    )\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory appState = abi.decode(encodedState, (AppState));\n        Action memory action = abi.decode(encodedAction, (Action));\n\n        AppState memory nextState = appState;\n\n        if (action.actionType == ActionType.COMMIT_TO_HASH) {\n\n            require(\n                appState.stage == Stage.WAITING_FOR_P1_COMMITMENT,\n                \"Must apply COMMIT_TO_HASH to WAITING_FOR_P1_COMMITMENT\"\n            );\n\n            nextState.stage = Stage.P1_COMMITTED_TO_HASH;\n            nextState.commitHash = action.actionHash;\n\n        } else if (action.actionType == ActionType.COMMIT_TO_NUM) {\n\n            require(\n                appState.stage == Stage.P1_COMMITTED_TO_HASH,\n                \"Must apply COMMIT_TO_NUM to P1_COMMITTED_TO_HASH\"\n            );\n\n            require(\n                action.number != 0,\n                \"It is considered invalid to use 0 as the number.\"\n            );\n\n            nextState.stage = Stage.P2_COMMITTED_TO_NUM;\n            nextState.playerSecondNumber = action.number;\n\n        } else if (action.actionType == ActionType.REVEAL_NUM) {\n\n            require(\n                appState.stage == Stage.P2_COMMITTED_TO_NUM,\n                \"Must apply REVEAL_NUM to P2_COMMITTED_TO_NUM\"\n            );\n\n            bytes32 expectedCommitHash = keccak256(\n                abi.encodePacked(action.actionHash, action.number)\n            );\n\n            require(\n                expectedCommitHash == appState.commitHash,\n                \"Number presented by P1 was not what was previously committed to.\"\n            );\n\n            if (action.number == 0) {\n                nextState.stage = Stage.P1_TRIED_TO_SUBMIT_ZERO;\n            } else {\n                nextState.stage = Stage.P1_REVEALED_NUM;\n                nextState.playerFirstNumber = action.number;\n                nextState.salt = action.actionHash;\n            }\n\n        } else {\n\n            revert(\"Invalid action type\");\n\n        }\n\n        nextState.versionNumber += 1;\n\n        return abi.encode(nextState);\n    }\n\n    function computeOutcome(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory appState = abi.decode(encodedState, (AppState));\n\n        // If P1 goes offline...\n        if (appState.stage == Stage.WAITING_FOR_P1_COMMITMENT) {\n            return abi.encode(LibOutcome.TwoPartyFixedOutcome.SEND_TO_ADDR_TWO);\n        }\n\n        // If P2 goes offline...\n        if (appState.stage == Stage.P1_COMMITTED_TO_HASH) {\n            return abi.encode(LibOutcome.TwoPartyFixedOutcome.SEND_TO_ADDR_ONE);\n        }\n\n        // If P1 goes offline...\n        if (appState.stage == Stage.P2_COMMITTED_TO_NUM) {\n            return abi.encode(LibOutcome.TwoPartyFixedOutcome.SEND_TO_ADDR_TWO);\n        }\n\n        // If P1 tried to cheat...\n        if (appState.stage == Stage.P1_TRIED_TO_SUBMIT_ZERO) {\n            return abi.encode(LibOutcome.TwoPartyFixedOutcome.SEND_TO_ADDR_TWO);\n        }\n\n        // Co-operative case\n        return abi.encode(\n            getWinningAmounts(\n                appState.playerFirstNumber,\n                appState.playerSecondNumber\n            )\n        );\n\n    }\n\n    function highRoller(bytes32 randomness)\n        public\n        pure\n        returns(uint8 playerFirstTotal, uint8 playerSecondTotal)\n    {\n        (\n            uint8 playerFirstRollOne,\n            uint8 playerFirstRollTwo,\n            uint8 playerSecondRollOne,\n            uint8 playerSecondRollTwo\n        ) = getPlayerRolls(randomness);\n        playerFirstTotal = playerFirstRollOne + playerFirstRollTwo;\n        playerSecondTotal = playerSecondRollOne + playerSecondRollTwo;\n    }\n\n    function getPlayerRolls(bytes32 randomness)\n        public // NOTE: This is used in app-root.tsx for the clientside dapp\n        pure\n        returns(uint8 playerFirstRollOne, uint8 playerFirstRollTwo, uint8 playerSecondRollOne, uint8 playerSecondRollTwo)\n    {\n        (\n            bytes8 hash1,\n            bytes8 hash2,\n            bytes8 hash3,\n            bytes8 hash4\n        ) = cutBytes32(randomness);\n        playerFirstRollOne = bytes8toDiceRoll(hash1);\n        playerFirstRollTwo = bytes8toDiceRoll(hash2);\n        playerSecondRollOne = bytes8toDiceRoll(hash3);\n        playerSecondRollTwo = bytes8toDiceRoll(hash4);\n    }\n\n    function getWinningAmounts(uint256 num1, uint256 num2)\n        internal\n        pure\n        returns (LibOutcome.TwoPartyFixedOutcome)\n    {\n        bytes32 randomSalt = calculateRandomSalt(num1, num2);\n\n        (uint8 playerFirstTotal, uint8 playerSecondTotal) = highRoller(randomSalt);\n\n        if (playerFirstTotal > playerSecondTotal) {\n            return LibOutcome.TwoPartyFixedOutcome.SEND_TO_ADDR_ONE;\n        }\n\n        if (playerFirstTotal < playerSecondTotal) {\n            return LibOutcome.TwoPartyFixedOutcome.SEND_TO_ADDR_TWO;\n        }\n\n        return LibOutcome.TwoPartyFixedOutcome.SPLIT_AND_SEND_TO_BOTH_ADDRS;\n\n    }\n\n    function calculateRandomSalt(uint256 num1, uint256 num2)\n        internal\n        pure\n        returns (bytes32)\n    {\n        return keccak256(abi.encodePacked(num1 * num2));\n    }\n\n    /// @notice Splits a bytes32 into 4 bytes8 by cutting every 8 bytes\n    /// @param h The bytes32 to be split\n    /// @dev Takes advantage of implicitly recognizing the length of each bytes8\n    ///      variable when being read by `mload`. We point to the start of each\n    ///      string (e.g., 0x08, 0x10) by incrementing by 8 bytes each time.\n    function cutBytes32(bytes32 h)\n        internal\n        pure\n        returns (bytes8 q1, bytes8 q2, bytes8 q3, bytes8 q4)\n    {\n        assembly {\n            let ptr := mload(0x40)\n            mstore(add(ptr, 0x00), h)\n            q1 := mload(add(ptr, 0x00))\n            q2 := mload(add(ptr, 0x08))\n            q3 := mload(add(ptr, 0x10))\n            q4 := mload(add(ptr, 0x18))\n        }\n    }\n\n    /// @notice Converts a bytes8 into a uint64 between 1-6\n    /// @param q The bytes8 to convert\n    /// @dev Splits this by using modulo 6 to get the uint\n    function bytes8toDiceRoll(bytes8 q)\n      internal\n      pure\n      returns (uint8)\n    {\n        return uint8(uint64(q) % 6);\n    }\n\n}\n"
    },
    "contracts/apps/NimApp.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../adjudicator/interfaces/CounterfactualApp.sol\";\nimport \"../funding/libs/LibOutcome.sol\";\n\n\n/*\nNormal-form Nim\nhttps://en.wikipedia.org/wiki/Nim\n*/\ncontract NimApp is CounterfactualApp {\n\n    struct Action {\n        uint256 pileIdx;\n        uint256 takeAmnt;\n    }\n\n    struct AppState {\n        uint256 versionNumber; // NOTE: This field is mandatory, do not modify!\n        uint256[3] pileHeights;\n    }\n\n    function isStateTerminal(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bool)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n        return isWin(state);\n    }\n\n    // NOTE: Function is being deprecated soon, do not modify!\n    function getTurnTaker(\n        bytes calldata encodedState,\n        address[] calldata participants\n    )\n        override\n        external\n        view\n        returns (address)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n        return participants[state.versionNumber % 2];\n    }\n\n    function applyAction(\n        bytes calldata encodedState, bytes calldata encodedAction\n    )\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n        Action memory action = abi.decode(encodedAction, (Action));\n\n        require(action.pileIdx < 3, \"pileIdx must be 0, 1 or 2\");\n        require(\n            state.pileHeights[action.pileIdx] >= action.takeAmnt, \"invalid pileIdx\"\n        );\n\n        AppState memory ret = state;\n\n        ret.pileHeights[action.pileIdx] -= action.takeAmnt;\n        ret.versionNumber += 1;\n\n        return abi.encode(ret);\n    }\n\n    function computeOutcome(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n\n        if (state.versionNumber % 2 == 0) {\n            return abi.encode(LibOutcome.TwoPartyFixedOutcome.SEND_TO_ADDR_ONE);\n        } else {\n            return abi.encode(LibOutcome.TwoPartyFixedOutcome.SEND_TO_ADDR_TWO);\n        }\n    }\n\n    function isWin(AppState memory state)\n        internal\n        pure\n        returns (bool)\n    {\n        return (\n            (state.pileHeights[0] == 0) && (state.pileHeights[1] == 0) && (state.pileHeights[2] == 0)\n        );\n    }\n\n\n}\n"
    },
    "contracts/apps/SimpleLinkedTransferApp.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../adjudicator/interfaces/CounterfactualApp.sol\";\nimport \"../funding/libs/LibOutcome.sol\";\n\n\n/// @title Simple Linked Transfer App\n/// @notice This contract allows users to claim a payment locked in\n///         the application if they provide the correct preImage\ncontract SimpleLinkedTransferApp is CounterfactualApp {\n\n    using SafeMath for uint256;\n\n    /**\n    * Assume the app is funded with the money already owed to receiver,\n    * as in the SimpleTwoPartySwapApp.\n    *\n    * This app can also not be used to send _multiple_ linked payments,\n    * only one can be redeemed with the preImage.\n    *\n    */\n\n    struct AppState {\n        LibOutcome.CoinTransfer[2] coinTransfers;\n        bytes32 linkedHash;\n        // need these for computing outcome\n        uint256 amount;\n        address assetId;\n        bytes32 paymentId;\n        bytes32 preImage;\n    }\n\n    struct Action {\n        bytes32 preImage;\n    }\n\n    function applyAction(\n        bytes calldata encodedState,\n        bytes calldata encodedAction\n    )\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n        Action memory action = abi.decode(encodedAction, (Action));\n\n        state.preImage = action.preImage;\n\n        return abi.encode(state);\n    }\n\n    function computeOutcome(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n        // TODO: whats the protection against passing a different hash?\n\n        bytes32 generatedHash = keccak256(\n            abi.encodePacked(\n                state.amount,\n                state.assetId,\n                state.paymentId,\n                state.preImage\n            )\n        );\n\n        LibOutcome.CoinTransfer[2] memory transfers;\n        if (generatedHash == state.linkedHash) {\n            /**\n             * If the hash is correct, finalize the state with provided transfers.\n             */\n            transfers = LibOutcome.CoinTransfer[2]([\n                LibOutcome.CoinTransfer(\n                    state.coinTransfers[0].to,\n                    /* should always be 0 */\n                    0\n                ),\n                LibOutcome.CoinTransfer(\n                    state.coinTransfers[1].to,\n                    /* should always be full value of linked payment */\n                    state.coinTransfers[0].amount\n                )\n            ]);\n        } else {\n            /**\n             * If the hash is not correct, finalize the state with reverted transfers.\n             */\n            transfers = LibOutcome.CoinTransfer[2]([\n                LibOutcome.CoinTransfer(\n                    state.coinTransfers[0].to,\n                    state.coinTransfers[0].amount\n                ),\n                LibOutcome.CoinTransfer(\n                    state.coinTransfers[1].to,\n                    0\n                )\n            ]);\n        }\n        return abi.encode(transfers);\n    }\n}\n"
    },
    "contracts/apps/SimpleSignedTransferApp.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../shared/libs/LibChannelCrypto.sol\";\nimport \"../adjudicator/interfaces/CounterfactualApp.sol\";\nimport \"../funding/libs/LibOutcome.sol\";\n\n\n/// @title Simple Signed Transfer App\n/// @notice This contract allows users to claim a payment locked in\n///         the application if the specified signed submits the correct\n///         signature for the provided data\ncontract SimpleSignedTransferApp is CounterfactualApp {\n    using LibChannelCrypto for bytes32;\n    using SafeMath for uint256;\n\n    struct AppState {\n        LibOutcome.CoinTransfer[2] coinTransfers;\n        address signer;\n        bytes32 paymentId;\n        bool finalized;\n    }\n\n    struct Action {\n        bytes32 data;\n        bytes signature;\n    }\n\n    function applyAction(\n        bytes calldata encodedState,\n        bytes calldata encodedAction\n    )\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n        Action memory action = abi.decode(encodedAction, (Action));\n\n        require(!state.finalized, \"Cannot take action on finalized state\");\n        bytes32 rawHash = keccak256(abi.encodePacked(action.data, state.paymentId));\n        require(state.signer == rawHash.verifyChannelMessage(action.signature), \"Incorrect signer recovered from signature\");\n\n        state.coinTransfers[1].amount = state.coinTransfers[0].amount;\n        state.coinTransfers[0].amount = 0;\n        state.finalized = true;\n\n        return abi.encode(state);\n    }\n\n    function computeOutcome(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n\n        return abi.encode(state.coinTransfers);\n    }\n\n    function getTurnTaker(\n        bytes calldata /* encodedState */,\n        address[] calldata participants\n    )\n        override\n        external\n        view\n        returns (address)\n    {\n        return participants[1]; // receiver should always be indexed at [1]\n    }\n\n    function isStateTerminal(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bool)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n        return state.finalized;\n    }\n}\n"
    },
    "contracts/apps/SimpleTransferApp.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../adjudicator/interfaces/CounterfactualApp.sol\";\nimport \"../funding/libs/LibOutcome.sol\";\n\n\n/// @title SimpleTwoPartySwapApp\n/// @notice This contract lets Alice transfer assets to Bob\ncontract SimpleTransferApp is CounterfactualApp {\n\n    using SafeMath for uint256;\n\n    struct AppState {\n        LibOutcome.CoinTransfer[2] coinTransfers;\n    }\n\n    function computeOutcome(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n\n        uint256 transferAmount = state.coinTransfers[0].amount;\n\n        state.coinTransfers[0].amount = 0;\n        state.coinTransfers[1].amount = transferAmount;\n\n        return abi.encode(state.coinTransfers);\n    }\n}\n"
    },
    "contracts/apps/SimpleTwoPartySwapApp.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../adjudicator/interfaces/CounterfactualApp.sol\";\nimport \"../funding/libs/LibOutcome.sol\";\n\n\n/// @title SimpleTwoPartySwapApp\n/// @notice This contract lets two parties swap one ERC20 or ETH asset for another\ncontract SimpleTwoPartySwapApp is CounterfactualApp {\n\n    using SafeMath for uint256;\n\n    struct AppState {\n        LibOutcome.CoinTransfer[][] coinTransfers;\n    }\n\n    function computeOutcome(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n\n        uint256 amountsA = state.coinTransfers[0][0].amount;\n        uint256 amountsB = state.coinTransfers[1][0].amount;\n\n        state.coinTransfers[0][0].amount = amountsB;\n        state.coinTransfers[1][0].amount = amountsA;\n\n        return abi.encode(state.coinTransfers);\n    }\n}\n"
    },
    "contracts/apps/TicTacToeApp.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../adjudicator/interfaces/CounterfactualApp.sol\";\nimport \"../funding/libs/LibOutcome.sol\";\n\n\ncontract TicTacToeApp is CounterfactualApp {\n\n    enum ActionType {\n        PLAY,\n        PLAY_AND_WIN,\n        PLAY_AND_DRAW,\n        DRAW\n    }\n\n    enum WinClaimType {\n        COL,\n        ROW,\n        DIAG,\n        CROSS_DIAG\n    }\n\n    struct WinClaim {\n        WinClaimType winClaimType;\n        uint256 idx;\n    }\n\n    // Constants for AppState::winner.\n    // If i = AppState::winner is not one of these, then\n    // players[i-1] has won.\n    uint256 constant GAME_IN_PROGRESS = 0;\n    uint256 constant GAME_DRAWN = 3;\n\n    // Constants for elements of AppState::board\n    // If i = AppState::board[x][y] is not one of these, then\n    // players[i-1] has played on (x, y)\n    uint256 constant EMPTY_SQUARE = 0;\n\n    struct AppState {\n        uint256 versionNumber; // NOTE: This field is mandatory, do not modify!\n        uint256 winner;\n        uint256[3][3] board;\n    }\n\n    struct Action {\n        ActionType actionType;\n        uint256 playX;\n        uint256 playY;\n        WinClaim winClaim;\n    }\n\n    function isStateTerminal(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bool)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n        return state.winner != GAME_IN_PROGRESS;\n    }\n\n    // NOTE: Function is being deprecated soon, do not modify!\n    function getTurnTaker(\n        bytes calldata encodedState,\n        address[] calldata participants\n    )\n        override\n        external\n        view\n        returns (address)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n        return participants[state.versionNumber % 2];\n    }\n\n    function applyAction(\n        bytes calldata encodedState, bytes calldata encodedAction\n    )\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n        Action memory action = abi.decode(encodedAction, (Action));\n\n        AppState memory postState;\n        if (action.actionType == ActionType.PLAY) {\n            postState = playMove(\n                state,\n                state.versionNumber % 2,\n                action.playX,\n                action.playY\n            );\n        } else if (action.actionType == ActionType.PLAY_AND_WIN) {\n            postState = playMove(\n                state,\n                state.versionNumber % 2,\n                action.playX,\n                action.playY\n            );\n            assertWin(state.versionNumber % 2, postState, action.winClaim);\n            postState.winner = (postState.versionNumber % 2) + 1;\n        } else if (action.actionType == ActionType.PLAY_AND_DRAW) {\n            postState = playMove(\n                state,\n                state.versionNumber % 2,\n                action.playX,\n                action.playY\n            );\n            assertBoardIsFull(postState);\n            postState.winner = 3;\n        } else if (action.actionType == ActionType.DRAW) {\n            assertBoardIsFull(state);\n            postState = state;\n            postState.winner = 3;\n        }\n\n        postState.versionNumber += 1;\n\n        return abi.encode(postState);\n    }\n\n    function computeOutcome(bytes calldata encodedState)\n      override\n      external\n      view\n      returns (bytes memory)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n\n        if (state.winner == 2) {\n            return abi.encode(LibOutcome.TwoPartyFixedOutcome.SEND_TO_ADDR_TWO);\n        } else if (state.winner == 1) {\n            return abi.encode(LibOutcome.TwoPartyFixedOutcome.SEND_TO_ADDR_ONE);\n        } else if (state.winner == GAME_DRAWN) {\n            return abi.encode(LibOutcome.TwoPartyFixedOutcome.SPLIT_AND_SEND_TO_BOTH_ADDRS);\n        } else {\n            if (state.versionNumber % 2 == 0) {\n                return abi.encode(LibOutcome.TwoPartyFixedOutcome.SEND_TO_ADDR_ONE);\n            } else if (state.versionNumber % 2 == 1) {\n                return abi.encode(LibOutcome.TwoPartyFixedOutcome.SEND_TO_ADDR_TWO);\n            }\n        }\n    }\n\n    function playMove(\n        AppState memory state,\n        uint256 playerId,\n        uint256 x,\n        uint256 y\n    )\n        internal\n        pure\n        returns (AppState memory)\n    {\n        require(state.board[x][y] == 0, \"playMove: square is not empty\");\n        require(\n            playerId == 0 || playerId == 1, \"playMove: playerId not in range [0, 1]\"\n        );\n\n        state.board[x][y] = playerId + 1;\n\n        return state;\n    }\n\n    function assertBoardIsFull(AppState memory preState)\n        internal\n        pure\n    {\n        for (uint256 i = 0; i < 3; i++) {\n            for (uint256 j = 0; j < 3; j++) {\n                require(\n                    preState.board[i][j] != 0, \"assertBoardIsFull: square is empty\"\n                );\n            }\n        }\n    }\n\n    function assertWin(\n        uint256 playerId,\n        AppState memory state,\n        WinClaim memory winClaim\n    )\n        internal\n        pure\n    {\n        uint256 expectedSquareState = playerId + 1;\n        if (winClaim.winClaimType == WinClaimType.COL) {\n            require(\n                state.board[winClaim.idx][0] == expectedSquareState, \"Win Claim not valid\"\n            );\n            require(\n                state.board[winClaim.idx][1] == expectedSquareState, \"Win Claim not valid\"\n            );\n            require(\n                state.board[winClaim.idx][2] == expectedSquareState, \"Win Claim not valid\"\n            );\n        } else if (winClaim.winClaimType == WinClaimType.ROW) {\n            require(\n                state.board[0][winClaim.idx] == expectedSquareState, \"Win Claim not valid\"\n            );\n            require(\n                state.board[1][winClaim.idx] == expectedSquareState, \"Win Claim not valid\"\n            );\n            require(\n                state.board[2][winClaim.idx] == expectedSquareState, \"Win Claim not valid\"\n            );\n        } else if (winClaim.winClaimType == WinClaimType.DIAG) {\n            require(state.board[0][0] == expectedSquareState, \"Win Claim not valid\");\n            require(state.board[1][1] == expectedSquareState, \"Win Claim not valid\");\n            require(state.board[2][2] == expectedSquareState, \"Win Claim not valid\");\n        } else if (winClaim.winClaimType == WinClaimType.CROSS_DIAG) {\n            require(state.board[2][0] == expectedSquareState, \"Win Claim not valid\");\n            require(state.board[1][1] == expectedSquareState, \"Win Claim not valid\");\n            require(state.board[0][2] == expectedSquareState, \"Win Claim not valid\");\n        }\n    }\n\n}\n"
    },
    "contracts/apps/UnidirectionalLinkedTransferApp.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../adjudicator/interfaces/CounterfactualApp.sol\";\nimport \"../funding/libs/LibOutcome.sol\";\n\n\n/// @title Unidirectional Linked Transfer App\n/// @notice This contract allows users to claim a payment locked in\n///         the application if they provide the correct preImage\ncontract UnidirectionalLinkedTransferApp is CounterfactualApp {\n\n    using SafeMath for uint256;\n\n    /**\n    * Assume the app is funded with the money already owed to receiver,\n    * as in the SimpleTwoPartySwapApp.\n    *\n    * This app can also not be used to send _multiple_ linked payments,\n    * only one can be redeemed with the preImage.\n    *\n    */\n\n    enum AppStage {\n        POST_FUND,\n        PAYMENT_CLAIMED,\n        CHANNEL_CLOSED\n    }\n\n    struct AppState {\n        AppStage stage;\n        LibOutcome.CoinTransfer[2] transfers;\n        bytes32 linkedHash;\n        // NOTE: These following parameters are soon\n        //       to be built in as framework-level\n        //       constants but for now must be app-level.\n        uint256 turnNum; // TODO: is this needed here?\n        bool finalized;\n    }\n\n    // theres really only one type of action here,\n    // the only reason to use the end channel action would\n    // be to allow the hub to uninstall the app to reclaim\n    // collateral. Since this can only be done while the recipient\n    // is online, you dont *need* an END_CHANNEL action type, you\n    // can just use an adjudicator.\n\n    // Questions: if the app is set up to have the transfers pre-assigned\n    // in the same way the swap app is atm, will the adjudicator know that\n    // if no correct preImage is included in the commitment, it should 0\n    // transfers?\n    // enum ActionType {\n    //   CLAIM_MONEY\n\n    //   // // NOTE: These following action will soon\n    //   // //       be built in as a framework-level\n    //   // //       constant but for now must be app-level.\n    //   // END_CHANNEL\n    // }\n\n    struct Action {\n        uint256 amount;\n        address assetId;\n        bytes32 paymentId;\n        bytes32 preImage;\n    }\n\n    function computeOutcome(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        return abi.encode(abi.decode(encodedState, (AppState)).transfers);\n    }\n\n    function applyAction(\n        bytes calldata encodedState,\n        bytes calldata encodedAction\n    )\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory state = abi.decode(\n            encodedState,\n            (AppState)\n        );\n\n        Action memory action = abi.decode(\n            encodedAction,\n            (Action)\n        );\n\n        bytes32 generatedHash = keccak256(\n            abi.encodePacked(\n                action.amount,\n                action.assetId,\n                action.paymentId,\n                action.preImage\n            )\n        );\n        if (generatedHash == state.linkedHash) {\n            /**\n             * If the hash is correct, finalize the state with provided transfers.\n             */\n            return abi.encode(\n                AppState(\n                    /* stage of app */\n                    AppStage.PAYMENT_CLAIMED,\n                    /* transfers */\n                    LibOutcome.CoinTransfer[2]([\n                        LibOutcome.CoinTransfer(\n                            state.transfers[0].to,\n                            /* should always be 0 */\n                            state.transfers[1].amount\n                        ),\n                        LibOutcome.CoinTransfer(\n                            state.transfers[1].to,\n                            /* should always be full value of linked payment */\n                            state.transfers[0].amount\n                        )\n                    ]),\n                    /* link hash */\n                    state.linkedHash,\n                    /* turnNum */\n                    state.turnNum + 1,\n                    /* finalized */\n                    true\n                )\n            );\n        } else {\n            /**\n             * If the hash is not correct, finalize the state with reverted transfers.\n             */\n            return abi.encode(\n                AppState(\n                    /* stage of app */\n                    AppStage.CHANNEL_CLOSED,\n                    /* transfers */\n                    LibOutcome.CoinTransfer[2]([\n                        LibOutcome.CoinTransfer(\n                            state.transfers[0].to,\n                            state.transfers[0].amount\n                        ),\n                        LibOutcome.CoinTransfer(\n                            state.transfers[1].to,\n                            state.transfers[1].amount\n                        )\n                    ]),\n                    /* link hash */\n                    state.linkedHash,\n                    /* turnNum */\n                    state.turnNum + 1,\n                    /* finalized */\n                    true\n                )\n            );\n        }\n    }\n\n    function getTurnTaker(\n        bytes calldata encodedState,\n        address[] calldata participants\n    )\n        override\n        external\n        view\n        returns (address)\n    {\n        return participants[\n            abi.decode(encodedState, (AppState)).turnNum % participants.length\n        ];\n    }\n\n    function isStateTerminal(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bool)\n    {\n        return abi.decode(encodedState, (AppState)).finalized;\n    }\n\n}\n"
    },
    "contracts/apps/UnidirectionalTransferApp.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"@openzeppelin/contracts/math/SafeMath.sol\";\nimport \"../adjudicator/interfaces/CounterfactualApp.sol\";\nimport \"../funding/libs/LibOutcome.sol\";\n\n\n/// @title Unidirectional Transfer App\n/// @notice This contract allows unidirectional coin transfers using the\n///         takeAction paradigm.\ncontract UnidirectionalTransferApp is CounterfactualApp {\n\n    using SafeMath for uint256;\n\n    /**\n      * The state machine is as follows:\n      *\n      *  turnNum =\n      *\n      *      0                  1                   2\n      *\n      * [ POST_FUND ] -> [ MONEY_SENT ] -> [[ CHANNEL_CLOSED ]]\n      *\n      *           SEND_MONEY          END_CHANNEL\n      *         only by sender        by receiver\n      *\n      *                           1\n      *\n      *               -> [[ CHANNEL_CLOSED ]]\n      *\n      *                       END_CHANNEL\n      *                        by sender\n      *\n      * [[ ]] represents a \"terminal\" state, where finalized = true.\n      *\n      * The lifecycle is as follows:\n      *\n      * 1. App is installed by both parties. Sender puts in TWO.\n      *\n      *    channelState = (\n      *      participants = [sender, recipient],\n      *      state = {\n      *        transfers: [to: sender, TWO], [to: recipient, ZERO]\n      *        turnNum = 0,\n      *        finalized = false\n      *      }\n      *    )\n      *\n      * 2. The sender wants to send money. Takes Action(SEND_MONEY, ONE)\n      *\n      *    channelState = (\n      *      participants = [sender, recipient],\n      *      state = {\n      *        transfers: [to: sender, ONE], [to: recipient, ONE]\n      *        turnNum = 1,\n      *        finalized = false\n      *      }\n      *    )\n      *\n      * 2. The sender wants to send _more_ money. Takes Action(SEND_MONEY, ONE)\n      *\n      *    channelState = (\n      *      participants = [sender, recipient],\n      *      state = {\n      *        transfers: [to: sender, ZERO], [to: recipient, TWO]\n      *        turnNum = 1,\n      *        finalized = false\n      *      }\n      *    )\n      *\n      *    Note, this means the recipient can choose which one they want.\n      *\n      * 3. Receiver wants to finish this. Take Action(END_CHANNEL)\n      *\n      *    channelState = (\n      *      participants = [sender, recipient],\n      *      state = {\n      *        transfers: [to: sender, ZERO], [to: recipient, TWO]\n      *        turnNum = 2,\n      *        finalized = true\n      *      }\n      *    )\n      *\n      */\n\n    enum AppStage {\n        POST_FUND,\n        MONEY_SENT,\n        CHANNEL_CLOSED\n    }\n\n    struct AppState {\n        AppStage stage;\n        LibOutcome.CoinTransfer[2] transfers;\n        // NOTE: These following parameters are soon\n        //       to be built in as framework-level\n        //       constants but for now must be app-level.\n        uint256 turnNum;\n        bool finalized;\n    }\n\n    enum ActionType {\n        SEND_MONEY,\n        // NOTE: These following action will soon\n        //       be built in as a framework-level\n        //       constant but for now must be app-level.\n        END_CHANNEL\n    }\n\n    struct Action {\n        ActionType actionType;\n        uint256 amount;\n    }\n\n    function getTurnTaker(\n        bytes calldata encodedState,\n        address[] calldata participants\n    )\n        override\n        external\n        view\n        returns (address)\n    {\n        return participants[\n            abi.decode(encodedState, (AppState)).turnNum % participants.length\n        ];\n    }\n\n    function computeOutcome(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (\n          bytes memory // Encoded version of a LibOutcome.CoinTransfer[2]\n        )\n    {\n        return abi.encode(abi.decode(encodedState, (AppState)).transfers);\n    }\n\n    function applyAction(\n        bytes calldata encodedState,\n        bytes calldata encodedAction\n    )\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory state = abi.decode(\n            encodedState,\n            (AppState)\n        );\n\n        Action memory action = abi.decode(\n            encodedAction,\n            (Action)\n        );\n\n        /**\n         * Anyone can close the channel at any time.\n         */\n        if (action.actionType == ActionType.END_CHANNEL) {\n            return abi.encode(\n                AppState(\n                    /* stage */\n                    AppStage.CHANNEL_CLOSED,\n                    /* transfers */\n                    state.transfers,\n                    /* turnNum */\n                    state.turnNum + 1,\n                    /* finalized */\n                    true\n                )\n            );\n        }\n\n        if (state.stage == AppStage.POST_FUND) {\n            if (action.actionType == ActionType.SEND_MONEY) {\n                return abi.encode(\n                    AppState(\n                        /* stage */\n                        AppStage.MONEY_SENT,\n                        /* transfers */\n                        LibOutcome.CoinTransfer[2]([\n                            LibOutcome.CoinTransfer(\n                                state.transfers[0].to,\n                                state.transfers[0].amount.sub(action.amount)\n                            ),\n                            LibOutcome.CoinTransfer(\n                                state.transfers[1].to,\n                                state.transfers[1].amount.add(action.amount)\n                            )\n                        ]),\n                        /* turnNum */\n                        state.turnNum + 1,\n                        /* finalized */\n                        false\n                      )\n                );\n            }\n\n            revert(\n                \"Invalid action. Valid actions from POST_FUND are {SEND_MONEY, END_CHANNEL}\"\n            );\n        }\n\n        revert(\"Invalid action. Valid actions from MONEY_SENT are {END_CHANNEL}\");\n\n    }\n\n    function isStateTerminal(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bool)\n    {\n        return abi.decode(encodedState, (AppState)).finalized;\n    }\n\n}\n"
    },
    "contracts/funding/ConditionalTransactionDelegateTarget.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"./state-deposit-holders/MultisigTransfer.sol\";\nimport \"../adjudicator/ChallengeRegistry.sol\";\nimport \"./libs/LibOutcome.sol\";\n\n\n/// @title ConditionalTransactionDelegateTarget\n/// @author Liam Horne - <liam@l4v.io>\ncontract ConditionalTransactionDelegateTarget is MultisigTransfer {\n\n    uint256 constant MAX_UINT256 = 2 ** 256 - 1;\n\n    struct FreeBalanceAppState {\n        address[] tokenAddresses;\n        // The inner array contains the list of CoinTransfers for a single asset type\n        // The outer array contains the list of asset balances for respecitve assets\n        // according to the indexing used in the `tokens` array above\n        LibOutcome.CoinTransfer[][] balances;\n        bytes32[] activeApps;\n    }\n\n    struct MultiAssetMultiPartyCoinTransferInterpreterParams {\n        uint256[] limit;\n        address[] tokenAddresses;\n    }\n\n    function withdrawWrapper(\n        address payable recipient,\n        address assetId,\n        uint256 amount,\n        bytes32 /* nonce */\n    )\n        public\n    {\n        multisigTransfer(recipient, assetId, amount);\n    }\n\n    function executeEffectOfFreeBalance(\n        ChallengeRegistry challengeRegistry,\n        bytes32 freeBalanceAppIdentityHash,\n        address multiAssetMultiPartyCoinTransferInterpreterAddress\n    )\n        public\n    {\n        FreeBalanceAppState memory freeBalanceAppState = abi.decode(\n            challengeRegistry.getOutcome(freeBalanceAppIdentityHash),\n            (FreeBalanceAppState)\n        );\n\n        uint256[] memory limits = new uint256[](\n            freeBalanceAppState.tokenAddresses.length\n        );\n\n        for (uint256 i = 0; i < freeBalanceAppState.tokenAddresses.length; i++) {\n            // The transaction's interpreter parameters are determined at the time\n            // of creation of the free balance; hence we cannot know how much will be\n            // deposited into it all-time. Relying on the app state is unsafe so\n            // we just give it full permissions by setting the limit to the max here.\n            limits[i] = MAX_UINT256;\n        }\n\n        (bool success, ) = multiAssetMultiPartyCoinTransferInterpreterAddress.delegatecall(\n            abi.encodeWithSignature(\n                \"interpretOutcomeAndExecuteEffect(bytes,bytes)\",\n                abi.encode(freeBalanceAppState.balances),\n                abi.encode(\n                    MultiAssetMultiPartyCoinTransferInterpreterParams(\n                        limits,\n                        freeBalanceAppState.tokenAddresses\n                    )\n                )\n            )\n        );\n\n        require(\n            success,\n            \"Execution of executeEffectOfFreeBalance failed\"\n        );\n    }\n\n    /// @notice Execute a fund transfer for a state channel app in a finalized state\n    /// @param appIdentityHash AppIdentityHash to be resolved\n    function executeEffectOfInterpretedAppOutcome(\n        ChallengeRegistry challengeRegistry,\n        bytes32 freeBalanceAppIdentityHash,\n        bytes32 appIdentityHash,\n        address interpreterAddress,\n        bytes memory interpreterParams\n    )\n        public\n    {\n        bytes32[] memory activeApps = abi.decode(\n            challengeRegistry.getOutcome(freeBalanceAppIdentityHash),\n            (FreeBalanceAppState)\n        ).activeApps;\n\n        bool appIsFunded = false;\n\n        for (uint256 i = 0; i < activeApps.length; i++) {\n            if (activeApps[i] == appIdentityHash) {\n                appIsFunded = true;\n            }\n        }\n\n        require(appIsFunded, \"Referenced AppInstance is not funded\");\n\n        bytes memory outcome = challengeRegistry.getOutcome(appIdentityHash);\n\n        (bool success, ) = interpreterAddress.delegatecall(\n            abi.encodeWithSignature(\n                \"interpretOutcomeAndExecuteEffect(bytes,bytes)\",\n                outcome,\n                interpreterParams\n            )\n        );\n\n        require(\n            success,\n            \"Execution of executeEffectOfInterpretedAppOutcome failed\"\n        );\n    }\n}\n"
    },
    "contracts/funding/state-deposit-holders/MultisigTransfer.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental ABIEncoderV2;\n\nimport \"./MultisigData.sol\";\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\n/// @title MultisigTransfer - Inherit from this contract\n/// for transfers out of the multisig.\n/// It does some necessary internal bookkeeping.\ncontract MultisigTransfer is MultisigData {\n\n    address constant CONVENTION_FOR_ETH_TOKEN_ADDRESS = address(0x0);\n\n    /// @notice Use this function for transfers of assets out of\n    /// the multisig. It does some necessary internal bookkeeping.\n    /// @param recipient the recipient of the transfer\n    /// @param assetId the asset to be transferred; token address for ERC20, 0 for Ether\n    /// @param amount the amount to be transferred\n\n    function multisigTransfer(\n        address payable recipient,\n        address assetId,\n        uint256 amount\n    ) public {\n        // Note, explicitly do NOT use safemath here. See discussion in: TODO\n        totalAmountWithdrawn[assetId] += amount;\n\n        if (assetId == CONVENTION_FOR_ETH_TOKEN_ADDRESS) {\n            // note: send() is deliberately used instead of transfer() here\n            // so that a revert does not stop the rest of the sends\n            // solium-disable-next-line security/no-send\n            recipient.send(amount);\n        } else {\n            IERC20(assetId).transfer(recipient, amount);\n        }\n    }\n\n}\n"
    },
    "contracts/funding/state-deposit-holders/MultisigData.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental ABIEncoderV2;\n\n\n/// @title MultisigData - data that is kept in the multisig\n/// and needs to be made available to contracts that the\n/// multisig delegatecalls to, e.g. interpreters.\ncontract MultisigData {\n\n    // The masterCopy address must occupy the first slot,\n    // because we're using the multisig as a proxy.\n    // Don't move or remove the following line!\n    address masterCopy;\n\n    mapping (address => uint256) public totalAmountWithdrawn;\n\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/IERC20.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/**\n * @dev Interface of the ERC20 standard as defined in the EIP.\n */\ninterface IERC20 {\n    /**\n     * @dev Returns the amount of tokens in existence.\n     */\n    function totalSupply() external view returns (uint256);\n\n    /**\n     * @dev Returns the amount of tokens owned by `account`.\n     */\n    function balanceOf(address account) external view returns (uint256);\n\n    /**\n     * @dev Moves `amount` tokens from the caller's account to `recipient`.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transfer(address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Returns the remaining number of tokens that `spender` will be\n     * allowed to spend on behalf of `owner` through {transferFrom}. This is\n     * zero by default.\n     *\n     * This value changes when {approve} or {transferFrom} are called.\n     */\n    function allowance(address owner, address spender) external view returns (uint256);\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the caller's tokens.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * IMPORTANT: Beware that changing an allowance with this method brings the risk\n     * that someone may use both the old and the new allowance by unfortunate\n     * transaction ordering. One possible solution to mitigate this race\n     * condition is to first reduce the spender's allowance to 0 and set the\n     * desired value afterwards:\n     * https://github.com/ethereum/EIPs/issues/20#issuecomment-263524729\n     *\n     * Emits an {Approval} event.\n     */\n    function approve(address spender, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Moves `amount` tokens from `sender` to `recipient` using the\n     * allowance mechanism. `amount` is then deducted from the caller's\n     * allowance.\n     *\n     * Returns a boolean value indicating whether the operation succeeded.\n     *\n     * Emits a {Transfer} event.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) external returns (bool);\n\n    /**\n     * @dev Emitted when `value` tokens are moved from one account (`from`) to\n     * another (`to`).\n     *\n     * Note that `value` may be zero.\n     */\n    event Transfer(address indexed from, address indexed to, uint256 value);\n\n    /**\n     * @dev Emitted when the allowance of a `spender` for an `owner` is set by\n     * a call to {approve}. `value` is the new allowance.\n     */\n    event Approval(address indexed owner, address indexed spender, uint256 value);\n}\n"
    },
    "contracts/funding/default-apps/DepositApp.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\nimport \"../../adjudicator/interfaces/CounterfactualApp.sol\";\nimport \"../state-deposit-holders/MinimumViableMultisig.sol\";\nimport \"../libs/LibOutcome.sol\";\n\n\n/// @title Deposit App\n/// @notice This contract allows a user to trustlessly deposit into a channel\n///         by attributing the difference in value of multisig to the depositor\n\n///         THIS CONTRACT WILL ONLY WORK FOR 2-PARTY CHANNELS!\ncontract DepositApp is CounterfactualApp {\n\n    address constant CONVENTION_FOR_ETH_TOKEN_ADDRESS = address(0x0);\n\n    struct AppState {\n        LibOutcome.CoinTransfer[2] transfers; // both amounts should be 0 in initial state\n        address payable multisigAddress;\n        address assetId;\n        uint256 startingTotalAmountWithdrawn;\n        uint256 startingMultisigBalance;\n    }\n\n    function computeOutcome(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n\n        uint256 endingTotalAmountWithdrawn;\n        uint256 endingMultisigBalance;\n\n        if (Address.isContract(state.multisigAddress)) {\n            endingTotalAmountWithdrawn = MinimumViableMultisig(state.multisigAddress).totalAmountWithdrawn(state.assetId);\n        } else {\n            endingTotalAmountWithdrawn = 0;\n        }\n\n        if (state.assetId == CONVENTION_FOR_ETH_TOKEN_ADDRESS) {\n            endingMultisigBalance = state.multisigAddress.balance;\n        } else {\n            endingMultisigBalance = IERC20(state.assetId).balanceOf(state.multisigAddress);\n        }\n\n        return abi.encode(LibOutcome.CoinTransfer[2]([\n            LibOutcome.CoinTransfer(\n                state.transfers[0].to,\n                // NOTE: deliberately do NOT use safemath here. For more info, see: TODO\n                (endingMultisigBalance - state.startingMultisigBalance) +\n                        (endingTotalAmountWithdrawn - state.startingTotalAmountWithdrawn)\n            ),\n            LibOutcome.CoinTransfer(\n                state.transfers[1].to,\n                /* should always be 0 */\n                0\n            )\n        ]));\n    }\n\n}\n"
    },
    "@openzeppelin/contracts/utils/Address.sol": {
      "content": "pragma solidity ^0.6.2;\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev Returns true if `account` is a contract.\n     *\n     * [IMPORTANT]\n     * ====\n     * It is unsafe to assume that an address for which this function returns\n     * false is an externally-owned account (EOA) and not a contract.\n     *\n     * Among others, `isContract` will return false for the following\n     * types of addresses:\n     *\n     *  - an externally-owned account\n     *  - a contract in construction\n     *  - an address where a contract will be created\n     *  - an address where a contract lived, but was destroyed\n     * ====\n     */\n    function isContract(address account) internal view returns (bool) {\n        // According to EIP-1052, 0x0 is the value returned for not-yet created accounts\n        // and 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470 is returned\n        // for accounts without code, i.e. `keccak256('')`\n        bytes32 codehash;\n        bytes32 accountHash = 0xc5d2460186f7233c927e7db2dcc703c0e500b653ca82273b7bfad8045d85a470;\n        // solhint-disable-next-line no-inline-assembly\n        assembly { codehash := extcodehash(account) }\n        return (codehash != accountHash && codehash != 0x0);\n    }\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://diligence.consensys.net/posts/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.5.11/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        require(address(this).balance >= amount, \"Address: insufficient balance\");\n\n        // solhint-disable-next-line avoid-low-level-calls, avoid-call-value\n        (bool success, ) = recipient.call{ value: amount }(\"\");\n        require(success, \"Address: unable to send value, recipient may have reverted\");\n    }\n}\n"
    },
    "contracts/funding/state-deposit-holders/MinimumViableMultisig.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental ABIEncoderV2;\n\nimport \"./MultisigData.sol\";\nimport \"../../shared/libs/LibCommitment.sol\";\nimport \"../../shared/libs/LibChannelCrypto.sol\";\n\n\n/// @title MinimumViableMultisig - A multisig wallet supporting the minimum\n/// features required for state channels support\n/// @author Liam Horne - <liam@l4v.io>\n/// @notice\n/// (a) Executes arbitrary transactions using `CALL` or `DELEGATECALL`\n/// (b) Requires n-of-n unanimous consent\n/// (c) Does not use on-chain address for signature verification\n/// (d) Uses hash-based instead of nonce-based replay protection\ncontract MinimumViableMultisig is MultisigData, LibCommitment {\n\n    using LibChannelCrypto for bytes32;\n\n    mapping(bytes32 => bool) isExecuted;\n\n    address[] private _owners;\n\n    enum Operation {\n        Call,\n        DelegateCall\n    }\n\n    receive() external payable { }\n\n    /// @notice Contract constructor\n    /// @param owners An array of unique addresses representing the multisig owners\n    function setup(address[] memory owners) public {\n        require(_owners.length == 0, \"Contract has been set up before\");\n        _owners = owners;\n    }\n\n    /// @notice Execute an n-of-n signed transaction specified by a (to, value, data, op) tuple\n    /// This transaction is a message call, i.e., either a CALL or a DELEGATECALL,\n    /// depending on the value of `op`. The arguments `to`, `value`, `data` are passed\n    /// as arguments to the CALL/DELEGATECALL.\n    /// @param to The destination address of the message call\n    /// @param value The amount of ETH being forwarded in the message call\n    /// @param data Any calldata being sent along with the message call\n    /// @param operation Specifies whether the message call is a `CALL` or a `DELEGATECALL`\n    /// @param signatures A sorted bytes string of concatenated signatures of each owner\n    function execTransaction(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Operation operation,\n        bytes[] memory signatures\n    )\n        public\n    {\n        bytes32 transactionHash = getTransactionHash(\n            to,\n            value,\n            data,\n            operation\n        );\n        require(\n            !isExecuted[transactionHash],\n            \"Transacation has already been executed\"\n        );\n\n        isExecuted[transactionHash] = true;\n\n        for (uint256 i = 0; i < _owners.length; i++) {\n            require(\n                _owners[i] == transactionHash.verifyChannelMessage(signatures[i]),\n                \"Invalid signature\"\n            );\n        }\n\n        execute(\n            to,\n            value,\n            data,\n            operation\n        );\n    }\n\n    /// @notice Compute a unique transaction hash for a particular (to, value, data, op) tuple\n    /// @return A unique hash that owners are expected to sign and submit to\n    /// @notice Note that two transactions with identical values of (to, value, data, op)\n    /// are not distinguished.\n    function getTransactionHash(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Operation operation\n    )\n        public\n        view\n        returns (bytes32)\n    {\n        return keccak256(\n            abi.encodePacked(\n                uint8(CommitmentTarget.MULTISIG),\n                address(this),\n                to,\n                value,\n                keccak256(data),\n                uint8(operation)\n            )\n        );\n    }\n\n    /// @notice A getter function for the owners of the multisig\n    /// @return An array of addresses representing the owners\n    function getOwners()\n        public\n        view\n        returns (address[] memory)\n    {\n        return _owners;\n    }\n\n    /// @notice Execute a transaction on behalf of the multisignature wallet\n    function execute(\n        address to,\n        uint256 value,\n        bytes memory data,\n        Operation operation\n    )\n        internal\n    {\n        if (operation == Operation.Call) {\n            require(executeCall(to, value, data), \"executeCall failed\");\n        } else if (operation == Operation.DelegateCall) {\n            require(executeDelegateCall(to, data), \"executeDelegateCall failed\");\n        }\n    }\n\n    /// @notice Execute a CALL on behalf of the multisignature wallet\n    /// @return success A boolean indicating if the transaction was successful or not\n    function executeCall(address to, uint256 value, bytes memory data)\n        internal\n        returns (bool success)\n    {\n        assembly {\n            success := call(not(0), to, value, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n    /// @notice Execute a DELEGATECALL on behalf of the multisignature wallet\n    /// @return success A boolean indicating if the transaction was successful or not\n    function executeDelegateCall(address to, bytes memory data)\n        internal\n        returns (bool success)\n    {\n        assembly {\n            success := delegatecall(not(0), to, add(data, 0x20), mload(data), 0, 0)\n        }\n    }\n\n}\n"
    },
    "contracts/funding/default-apps/FinalizedApp.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"./IdentityApp.sol\";\n\n\ncontract FinalizedApp is IdentityApp {\n\n    function isStateTerminal(bytes calldata)\n        override\n        external\n        view\n        returns (bool)\n    {\n        return true;\n    }\n\n}\n"
    },
    "contracts/funding/default-apps/IdentityApp.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../../adjudicator/interfaces/CounterfactualApp.sol\";\n\n\ncontract IdentityApp is CounterfactualApp {\n\n    function computeOutcome(bytes calldata encodedState)\n        override\n        virtual\n        external\n        view\n        returns (bytes memory)\n    {\n        return encodedState;\n    }\n\n}\n"
    },
    "contracts/funding/default-apps/TimeLockedPassthrough.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../../adjudicator/ChallengeRegistry.sol\";\nimport \"../../adjudicator/interfaces/CounterfactualApp.sol\";\n\n\n/// @notice TimeLockedPassThrough - Before `switchesOutcomeAt`, this contract\n/// should return the exact same outcome as the outcome `targetAppIdentityHash`\n///  returns, allowing it to \"pass through\" unaltered.\n///\n/// However, after `switchesOutcomeAt`, it should return `defaultOutcome`.\n/// `challengeRegistryAddress` is used to look up the outcome.\n///\n/// This contract is applied to virtual apps for two reasons:\n///\n/// 1. After the pre-agreed intermediation period elapses, the outcome\n///    must be fixed to the default (cannot be changed without\n///    the intermediary's consent) to allow them to safely get back their\n///    collateral.\n///\n/// 2. During the installation and uninstallation of the virtual app,\n///    this contract must be set to the default outcome, so that if funding\n///    fails halfway, the intermediary can dispute both channels safely\ncontract TimeLockedPassThrough {\n\n    struct AppState {\n        address challengeRegistryAddress;\n        bytes32 targetAppIdentityHash;\n        uint256 switchesOutcomeAt;\n        bytes defaultOutcome;\n    }\n\n    function computeOutcome(bytes calldata encodedState)\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory appState = abi.decode(encodedState, (AppState));\n\n        if (block.number >= appState.switchesOutcomeAt) {\n            return appState.defaultOutcome;\n        }\n\n        return ChallengeRegistry(\n            appState.challengeRegistryAddress\n        ).getOutcome(\n            appState.targetAppIdentityHash\n        );\n    }\n}\n"
    },
    "contracts/funding/default-apps/WithdrawApp.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../../shared/libs/LibChannelCrypto.sol\";\nimport \"../../adjudicator/interfaces/CounterfactualApp.sol\";\nimport \"../libs/LibOutcome.sol\";\n\n\n/// @title Withdraw App\n/// @notice This contract allows a user to trustlessly generate a withdrawal\n///         commitment by unlocking funds conditionally upon valid counterparty sig\n\n///         THIS CONTRACT WILL ONLY WORK FOR 2-PARTY CHANNELS!\ncontract WithdrawApp is CounterfactualApp {\n    using LibChannelCrypto for bytes32;\n\n    struct AppState {\n        // Note:\n        // transfers[0].to == recipient;\n        // transfers[0].amount == withdrawAmount;\n        LibOutcome.CoinTransfer[2] transfers;\n        bytes[2] signatures;\n        address[2] signers; // must be multisig participants with withdrawer at [0]\n        bytes32 data;\n        bytes32 nonce;\n        bool finalized;\n    }\n\n    struct Action {\n        bytes signature;\n    }\n\n    function isStateTerminal(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bool)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n        return state.finalized;\n    }\n\n    function getTurnTaker(\n        bytes calldata encodedState,\n        address[] calldata /* participants */\n    )\n        override\n        external\n        view\n        returns (address)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n        return state.signers[1];\n    }\n\n/// Assume that the initial state contains data, signers[], and signatures[0]\n/// The action, then, must be called by the withdrawal counterparty who submits\n/// their own signature on the withdrawal commitment data payload.\n    function applyAction(\n        bytes calldata encodedState,\n        bytes calldata encodedAction\n    )\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n        Action memory action = abi.decode(encodedAction, (Action));\n\n        require(!state.finalized, \"cannot take action on a finalized state\");\n        require(state.signers[0] == state.data.verifyChannelMessage(state.signatures[0]), \"invalid withdrawer signature\");\n        require(state.signers[1] == state.data.verifyChannelMessage(action.signature), \"invalid counterparty signature\");\n\n        state.signatures[1] = action.signature;\n        state.finalized = true;\n\n        return abi.encode(state);\n    }\n\n    function computeOutcome(bytes calldata encodedState)\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        AppState memory state = abi.decode(encodedState, (AppState));\n        LibOutcome.CoinTransfer[2] memory transfers;\n\n        if (state.finalized) {\n            /**\n             * If the state is finalized, zero out the withdrawer's balance\n             */\n            transfers = LibOutcome.CoinTransfer[2]([\n                LibOutcome.CoinTransfer(\n                    state.transfers[0].to,\n                    /* should be set to 0 */\n                    0\n                ),\n                LibOutcome.CoinTransfer(\n                    state.transfers[1].to,\n                    /* should always be 0 */\n                    0\n                )\n            ]);\n        } else {\n            /**\n             * If the state is not finalized, cancel the withdrawal\n             */\n            transfers = LibOutcome.CoinTransfer[2]([\n                LibOutcome.CoinTransfer(\n                    state.transfers[0].to,\n                    state.transfers[0].amount\n                ),\n                LibOutcome.CoinTransfer(\n                    state.transfers[1].to,\n                    0\n                )\n            ]);\n        }\n        return abi.encode(transfers);\n    }\n}\n"
    },
    "contracts/funding/Interpreter.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\n\ninterface Interpreter {\n    function interpretOutcomeAndExecuteEffect(\n        bytes calldata,\n        bytes calldata\n    )\n        external;\n}\n"
    },
    "contracts/funding/interpreters/MultiAssetMultiPartyCoinTransferInterpreter.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../state-deposit-holders/MultisigTransfer.sol\";\nimport \"../libs/LibOutcome.sol\";\nimport \"../Interpreter.sol\";\n\n\ncontract MultiAssetMultiPartyCoinTransferInterpreter is MultisigTransfer, Interpreter {\n\n    uint256 constant MAX_UINT256 = 2 ** 256 - 1;\n\n    struct MultiAssetMultiPartyCoinTransferInterpreterParams {\n        uint256[] limit;\n        address[] tokenAddresses;\n    }\n\n    // NOTE: This is useful for writing tests, but is bad practice\n    // to have in the contract when deploying it. We do not want people\n    // to send funds to this contract in any scenario.\n    receive() external payable { }\n\n    function interpretOutcomeAndExecuteEffect(\n        bytes calldata encodedOutcome,\n        bytes calldata encodedParams\n    )\n        override\n        external\n    {\n        MultiAssetMultiPartyCoinTransferInterpreterParams memory params = abi.decode(\n            encodedParams,\n            (MultiAssetMultiPartyCoinTransferInterpreterParams)\n        );\n\n        LibOutcome.CoinTransfer[][] memory coinTransferListOfLists = abi.decode(\n            encodedOutcome,\n            (LibOutcome.CoinTransfer[][])\n        );\n\n        for (uint256 i = 0; i < coinTransferListOfLists.length; i++) {\n\n            address tokenAddress = params.tokenAddresses[i];\n            uint256 limitRemaining = params.limit[i];\n            LibOutcome.CoinTransfer[] memory coinTransferList = coinTransferListOfLists[i];\n\n            for (uint256 j = 0; j < coinTransferList.length; j++) {\n\n                LibOutcome.CoinTransfer memory coinTransfer = coinTransferList[j];\n\n                address payable to = address(uint160(coinTransfer.to));\n\n                if (coinTransfer.amount > 0) {\n                    limitRemaining -= coinTransfer.amount;\n                    multisigTransfer(to, tokenAddress, coinTransfer.amount);\n                }\n\n            }\n\n            // NOTE: If the limit is MAX_UINT256 it can bypass this check.\n            // We do this for the FreeBalanceApp since its values change.\n            if (params.limit[i] != MAX_UINT256) {\n                require(\n                    limitRemaining == 0,\n                    \"Sum of total amounts received from outcome did not equate to limits.\"\n                );\n            }\n\n        }\n    }\n\n}\n"
    },
    "contracts/funding/interpreters/SingleAssetTwoPartyCoinTransferInterpreter.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../state-deposit-holders/MultisigTransfer.sol\";\nimport \"../libs/LibOutcome.sol\";\nimport \"../Interpreter.sol\";\n\n\n/**\n * This file is excluded from ethlint/solium because of this issue:\n * https://github.com/duaraghav8/Ethlint/issues/261\n */\ncontract SingleAssetTwoPartyCoinTransferInterpreter is MultisigTransfer, Interpreter {\n\n    struct Params {\n        uint256 limit;\n        address tokenAddress;\n    }\n    // NOTE: This is useful for writing tests, but is bad practice\n    // to have in the contract when deploying it. We do not want people\n    // to send funds to this contract in any scenario.\n    receive() external payable { }\n\n    function interpretOutcomeAndExecuteEffect(\n        bytes calldata encodedOutput,\n        bytes calldata encodedParams\n    )\n        override\n        external\n    {\n        Params memory params = abi.decode(encodedParams, (Params));\n\n        LibOutcome.CoinTransfer[2] memory outcome = abi.decode(\n            encodedOutput,\n            (LibOutcome.CoinTransfer[2])\n        );\n\n        multisigTransfer(outcome[0].to, params.tokenAddress, outcome[0].amount);\n        multisigTransfer(outcome[1].to, params.tokenAddress, outcome[1].amount);\n    }\n\n}\n"
    },
    "contracts/funding/interpreters/TwoPartyFixedOutcomeInterpreter.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../state-deposit-holders/MultisigTransfer.sol\";\nimport \"../Interpreter.sol\";\nimport \"../libs/LibOutcome.sol\";\n\n\n/// @notice\n/// Asset: Single Asset, ETH or ERC20\n/// OutcomeType: TwoPartyFixedOutcome\n/// The committed coins are sent to one of params.playerAddrs\n/// or split in half according to the outcome\ncontract TwoPartyFixedOutcomeInterpreter is MultisigTransfer, Interpreter {\n\n    struct Params {\n        address payable[2] playerAddrs;\n        uint256 amount;\n        address tokenAddress;\n    }\n\n    function interpretOutcomeAndExecuteEffect(\n        bytes calldata encodedOutcome,\n        bytes calldata encodedParams\n    )\n        override\n        external\n    {\n        LibOutcome.TwoPartyFixedOutcome outcome = abi.decode(\n            encodedOutcome,\n            (LibOutcome.TwoPartyFixedOutcome)\n        );\n\n        Params memory params = abi.decode(encodedParams, (Params));\n\n        if (outcome == LibOutcome.TwoPartyFixedOutcome.SEND_TO_ADDR_ONE) {\n            multisigTransfer(params.playerAddrs[0], params.tokenAddress, params.amount);\n        } else if (outcome == LibOutcome.TwoPartyFixedOutcome.SEND_TO_ADDR_TWO) {\n            multisigTransfer(params.playerAddrs[1], params.tokenAddress, params.amount);\n        } else {\n            /**\n             * A functioning app should return SPLIT_AND_SEND_TO_BOTH_ADDRS\n             * to indicate that the committed asset should be split, hence by right\n             * we can revert here if the outcome is something other than that, since we\n             * would have handled all cases; instead we choose to handle all other outcomes\n             * as if they were SPLIT.\n             */\n            multisigTransfer(params.playerAddrs[0], params.tokenAddress, params.amount / 2);\n            multisigTransfer(params.playerAddrs[1], params.tokenAddress, params.amount - params.amount / 2);\n        }\n    }\n\n}\n"
    },
    "contracts/funding/proxies/Proxy.sol": {
      "content": "pragma solidity 0.6.7;\n\n\n/// @title Proxy - Generic proxy contract allows to execute all transactions applying the code of a master contract.\n/// @author Stefan George - <stefan@gnosis.io>\n/// @author Richard Meissner - <richard@gnosis.io>\ncontract Proxy {\n\n    // masterCopy always needs to be first declared variable, to ensure that it is at the same location in the contracts to which calls are delegated.\n    // To reduce deployment costs this variable is internal and needs to be retrieved via `getStorageAt`\n    address internal masterCopy;\n\n    /// @dev Constructor function sets address of master copy contract.\n    /// @param _masterCopy Master copy address.\n    constructor(address _masterCopy)\n        public\n    {\n        require(_masterCopy != address(0), \"Invalid master copy address provided\");\n        masterCopy = _masterCopy;\n    }\n\n    /// @dev Fallback function forwards all transactions and returns all received return data.\n    fallback()\n        external\n        payable\n    {\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            let _masterCopy := and(sload(0), 0xffffffffffffffffffffffffffffffffffffffff)\n            calldatacopy(0, 0, calldatasize())\n            let success := delegatecall(gas(), _masterCopy, 0, calldatasize(), 0, 0)\n            returndatacopy(0, 0, returndatasize())\n            if eq(success, 0) { revert(0, returndatasize()) }\n            return(0, returndatasize())\n        }\n    }\n}\n"
    },
    "contracts/funding/proxies/ProxyFactory.sol": {
      "content": "pragma solidity 0.6.7;\n\nimport \"./Proxy.sol\";\n\n\n/// @title Proxy Factory - Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n/// @author Stefan George - <stefan@gnosis.pm>\ncontract ProxyFactory {\n\n    event ProxyCreation(Proxy proxy);\n\n    /// @dev Allows to get the address for a new proxy contact created via `createProxyWithNonce`\n    ///    This method is only meant for address calculation purpose when you use an initializer that would revert,\n    ///    therefore the response is returned with a revert. When calling this method set `from` to the address of the proxy factory.\n    /// @param _mastercopy Address of master copy.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function calculateCreateProxyWithNonceAddress(\n        address _mastercopy,\n        bytes calldata initializer,\n        uint256 saltNonce\n    )\n        external\n        returns (Proxy proxy)\n    {\n        proxy = deployProxyWithNonce(_mastercopy, initializer, saltNonce);\n        revert(string(abi.encodePacked(proxy)));\n    }\n\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n    /// @param masterCopy Address of master copy.\n    /// @param data Payload for message call sent to new proxy contract.\n    function createProxy(address masterCopy, bytes memory data)\n        public\n        returns (Proxy proxy)\n    {\n        proxy = new Proxy(masterCopy);\n        if (data.length > 0) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n              if eq(call(gas(), proxy, 0, add(data, 0x20), mload(data), 0, 0), 0) { revert(0, 0) }\n            }\n        }\n        emit ProxyCreation(proxy);\n    }\n\n    /// @dev Allows to retrieve the runtime code of a deployed Proxy. This can be used to check that the expected Proxy was deployed.\n    function proxyRuntimeCode() public pure returns (bytes memory) {\n        return type(Proxy).runtimeCode;\n    }\n\n    /// @dev Allows to retrieve the creation code used for the Proxy deployment. With this it is easily possible to calculate predicted address.\n    function proxyCreationCode() public pure returns (bytes memory) {\n        return type(Proxy).creationCode;\n    }\n\n    /// @dev Allows to create new proxy contact and execute a message call to the new proxy within one transaction.\n    /// @param _mastercopy Address of master copy.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function createProxyWithNonce(\n        address _mastercopy,\n        bytes memory initializer,\n        uint256 saltNonce\n    )\n        public\n        returns (Proxy proxy)\n    {\n        proxy = deployProxyWithNonce(_mastercopy, initializer, saltNonce);\n        if (initializer.length > 0) {\n            // solium-disable-next-line security/no-inline-assembly\n            assembly {\n                if eq(call(gas(), proxy, 0, add(initializer, 0x20), mload(initializer), 0, 0), 0) { revert(0,0) }\n            }\n        }\n        emit ProxyCreation(proxy);\n    }\n\n    /// @dev Allows to create new proxy contact using CREATE2 but it doesn't run the initializer.\n    ///    This method is only meant as an utility to be called from other methods\n    /// @param _mastercopy Address of master copy.\n    /// @param initializer Payload for message call sent to new proxy contract.\n    /// @param saltNonce Nonce that will be used to generate the salt to calculate the address of the new proxy contract.\n    function deployProxyWithNonce(\n        address _mastercopy,\n        bytes memory initializer,\n        uint256 saltNonce\n    )\n        internal\n        returns (Proxy proxy)\n    {\n        // If the initializer changes the proxy address should change too. Hashing the initializer data is cheaper than just concatinating it\n        bytes32 salt = keccak256(\n            abi.encodePacked(keccak256(initializer), saltNonce)\n        );\n\n        bytes memory deploymentData = abi.encodePacked(\n            type(Proxy).creationCode, uint256(_mastercopy)\n        );\n        // solium-disable-next-line security/no-inline-assembly\n        assembly {\n            proxy := create2(0x0, add(0x20, deploymentData), mload(deploymentData), salt)\n            let codeSize := extcodesize(proxy)\n            if eq(codeSize, 0) { revert(0, 0) }\n        }\n    }\n\n}\n"
    },
    "contracts/funding/test-fixtures/DelegateProxy.sol": {
      "content": "pragma solidity 0.6.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/IERC20.sol\";\n\ncontract DelegateProxy {\n    receive() external payable { }\n\n    mapping(address => uint256) public totalAmountWithdrawn;\n    address constant CONVENTION_FOR_ETH_TOKEN_ADDRESS = address(0x0);\n\n    function delegate(address to, bytes memory data) public {\n        // solium-disable-next-line security/no-low-level-calls\n        (bool success, ) = to.delegatecall(data);\n        require(success, \"Delegate call failed.\");\n    }\n\n    function withdraw(address assetId, address payable recipient, uint256 amount) public {\n        totalAmountWithdrawn[assetId] += amount;\n        if (assetId == CONVENTION_FOR_ETH_TOKEN_ADDRESS) {\n            recipient.send(amount);\n        } else {\n            IERC20(assetId).transfer(recipient, amount);\n        }\n    }\n}\n"
    },
    "contracts/funding/test-fixtures/DolphinCoin.sol": {
      "content": "pragma solidity 0.6.7;\n\nimport \"@openzeppelin/contracts/token/ERC20/ERC20.sol\";\n\n\ncontract DolphinCoin is ERC20(\"DolphinCoin\", \"DOC\") {\n    uint8 public constant DECIMALS = 18;\n    uint256 public constant INITIAL_SUPPLY = 10_000 * (uint256(10) ** DECIMALS);\n\n    /**\n     * @dev Constructor that gives msg.sender all of existing tokens.\n     */\n    constructor() public {\n        _setupDecimals(DECIMALS);\n        _mint(msg.sender, INITIAL_SUPPLY);\n    }\n}\n"
    },
    "@openzeppelin/contracts/token/ERC20/ERC20.sol": {
      "content": "pragma solidity ^0.6.0;\n\nimport \"../../GSN/Context.sol\";\nimport \"./IERC20.sol\";\nimport \"../../math/SafeMath.sol\";\nimport \"../../utils/Address.sol\";\n\n/**\n * @dev Implementation of the {IERC20} interface.\n *\n * This implementation is agnostic to the way tokens are created. This means\n * that a supply mechanism has to be added in a derived contract using {_mint}.\n * For a generic mechanism see {ERC20MinterPauser}.\n *\n * TIP: For a detailed writeup see our guide\n * https://forum.zeppelin.solutions/t/how-to-implement-erc20-supply-mechanisms/226[How\n * to implement supply mechanisms].\n *\n * We have followed general OpenZeppelin guidelines: functions revert instead\n * of returning `false` on failure. This behavior is nonetheless conventional\n * and does not conflict with the expectations of ERC20 applications.\n *\n * Additionally, an {Approval} event is emitted on calls to {transferFrom}.\n * This allows applications to reconstruct the allowance for all accounts just\n * by listening to said events. Other implementations of the EIP may not emit\n * these events, as it isn't required by the specification.\n *\n * Finally, the non-standard {decreaseAllowance} and {increaseAllowance}\n * functions have been added to mitigate the well-known issues around setting\n * allowances. See {IERC20-approve}.\n */\ncontract ERC20 is Context, IERC20 {\n    using SafeMath for uint256;\n    using Address for address;\n\n    mapping (address => uint256) private _balances;\n\n    mapping (address => mapping (address => uint256)) private _allowances;\n\n    uint256 private _totalSupply;\n\n    string private _name;\n    string private _symbol;\n    uint8 private _decimals;\n\n    /**\n     * @dev Sets the values for {name} and {symbol}, initializes {decimals} with\n     * a default value of 18.\n     *\n     * To select a different value for {decimals}, use {_setupDecimals}.\n     *\n     * All three of these values are immutable: they can only be set once during\n     * construction.\n     */\n    constructor (string memory name, string memory symbol) public {\n        _name = name;\n        _symbol = symbol;\n        _decimals = 18;\n    }\n\n    /**\n     * @dev Returns the name of the token.\n     */\n    function name() public view returns (string memory) {\n        return _name;\n    }\n\n    /**\n     * @dev Returns the symbol of the token, usually a shorter version of the\n     * name.\n     */\n    function symbol() public view returns (string memory) {\n        return _symbol;\n    }\n\n    /**\n     * @dev Returns the number of decimals used to get its user representation.\n     * For example, if `decimals` equals `2`, a balance of `505` tokens should\n     * be displayed to a user as `5,05` (`505 / 10 ** 2`).\n     *\n     * Tokens usually opt for a value of 18, imitating the relationship between\n     * Ether and Wei. This is the value {ERC20} uses, unless {_setupDecimals} is\n     * called.\n     *\n     * NOTE: This information is only used for _display_ purposes: it in\n     * no way affects any of the arithmetic of the contract, including\n     * {IERC20-balanceOf} and {IERC20-transfer}.\n     */\n    function decimals() public view returns (uint8) {\n        return _decimals;\n    }\n\n    /**\n     * @dev See {IERC20-totalSupply}.\n     */\n    function totalSupply() public view override returns (uint256) {\n        return _totalSupply;\n    }\n\n    /**\n     * @dev See {IERC20-balanceOf}.\n     */\n    function balanceOf(address account) public view override returns (uint256) {\n        return _balances[account];\n    }\n\n    /**\n     * @dev See {IERC20-transfer}.\n     *\n     * Requirements:\n     *\n     * - `recipient` cannot be the zero address.\n     * - the caller must have a balance of at least `amount`.\n     */\n    function transfer(address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(_msgSender(), recipient, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-allowance}.\n     */\n    function allowance(address owner, address spender) public view virtual override returns (uint256) {\n        return _allowances[owner][spender];\n    }\n\n    /**\n     * @dev See {IERC20-approve}.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function approve(address spender, uint256 amount) public virtual override returns (bool) {\n        _approve(_msgSender(), spender, amount);\n        return true;\n    }\n\n    /**\n     * @dev See {IERC20-transferFrom}.\n     *\n     * Emits an {Approval} event indicating the updated allowance. This is not\n     * required by the EIP. See the note at the beginning of {ERC20};\n     *\n     * Requirements:\n     * - `sender` and `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     * - the caller must have allowance for ``sender``'s tokens of at least\n     * `amount`.\n     */\n    function transferFrom(address sender, address recipient, uint256 amount) public virtual override returns (bool) {\n        _transfer(sender, recipient, amount);\n        _approve(sender, _msgSender(), _allowances[sender][_msgSender()].sub(amount, \"ERC20: transfer amount exceeds allowance\"));\n        return true;\n    }\n\n    /**\n     * @dev Atomically increases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     */\n    function increaseAllowance(address spender, uint256 addedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].add(addedValue));\n        return true;\n    }\n\n    /**\n     * @dev Atomically decreases the allowance granted to `spender` by the caller.\n     *\n     * This is an alternative to {approve} that can be used as a mitigation for\n     * problems described in {IERC20-approve}.\n     *\n     * Emits an {Approval} event indicating the updated allowance.\n     *\n     * Requirements:\n     *\n     * - `spender` cannot be the zero address.\n     * - `spender` must have allowance for the caller of at least\n     * `subtractedValue`.\n     */\n    function decreaseAllowance(address spender, uint256 subtractedValue) public virtual returns (bool) {\n        _approve(_msgSender(), spender, _allowances[_msgSender()][spender].sub(subtractedValue, \"ERC20: decreased allowance below zero\"));\n        return true;\n    }\n\n    /**\n     * @dev Moves tokens `amount` from `sender` to `recipient`.\n     *\n     * This is internal function is equivalent to {transfer}, and can be used to\n     * e.g. implement automatic token fees, slashing mechanisms, etc.\n     *\n     * Emits a {Transfer} event.\n     *\n     * Requirements:\n     *\n     * - `sender` cannot be the zero address.\n     * - `recipient` cannot be the zero address.\n     * - `sender` must have a balance of at least `amount`.\n     */\n    function _transfer(address sender, address recipient, uint256 amount) internal virtual {\n        require(sender != address(0), \"ERC20: transfer from the zero address\");\n        require(recipient != address(0), \"ERC20: transfer to the zero address\");\n\n        _beforeTokenTransfer(sender, recipient, amount);\n\n        _balances[sender] = _balances[sender].sub(amount, \"ERC20: transfer amount exceeds balance\");\n        _balances[recipient] = _balances[recipient].add(amount);\n        emit Transfer(sender, recipient, amount);\n    }\n\n    /** @dev Creates `amount` tokens and assigns them to `account`, increasing\n     * the total supply.\n     *\n     * Emits a {Transfer} event with `from` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `to` cannot be the zero address.\n     */\n    function _mint(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: mint to the zero address\");\n\n        _beforeTokenTransfer(address(0), account, amount);\n\n        _totalSupply = _totalSupply.add(amount);\n        _balances[account] = _balances[account].add(amount);\n        emit Transfer(address(0), account, amount);\n    }\n\n    /**\n     * @dev Destroys `amount` tokens from `account`, reducing the\n     * total supply.\n     *\n     * Emits a {Transfer} event with `to` set to the zero address.\n     *\n     * Requirements\n     *\n     * - `account` cannot be the zero address.\n     * - `account` must have at least `amount` tokens.\n     */\n    function _burn(address account, uint256 amount) internal virtual {\n        require(account != address(0), \"ERC20: burn from the zero address\");\n\n        _beforeTokenTransfer(account, address(0), amount);\n\n        _balances[account] = _balances[account].sub(amount, \"ERC20: burn amount exceeds balance\");\n        _totalSupply = _totalSupply.sub(amount);\n        emit Transfer(account, address(0), amount);\n    }\n\n    /**\n     * @dev Sets `amount` as the allowance of `spender` over the `owner`s tokens.\n     *\n     * This is internal function is equivalent to `approve`, and can be used to\n     * e.g. set automatic allowances for certain subsystems, etc.\n     *\n     * Emits an {Approval} event.\n     *\n     * Requirements:\n     *\n     * - `owner` cannot be the zero address.\n     * - `spender` cannot be the zero address.\n     */\n    function _approve(address owner, address spender, uint256 amount) internal virtual {\n        require(owner != address(0), \"ERC20: approve from the zero address\");\n        require(spender != address(0), \"ERC20: approve to the zero address\");\n\n        _allowances[owner][spender] = amount;\n        emit Approval(owner, spender, amount);\n    }\n\n    /**\n     * @dev Sets {decimals} to a value other than the default one of 18.\n     *\n     * WARNING: This function should only be called from the constructor. Most\n     * applications that interact with token contracts will not expect\n     * {decimals} to ever change, and may work incorrectly if it does.\n     */\n    function _setupDecimals(uint8 decimals_) internal {\n        _decimals = decimals_;\n    }\n\n    /**\n     * @dev Hook that is called before any transfer of tokens. This includes\n     * minting and burning.\n     *\n     * Calling conditions:\n     *\n     * - when `from` and `to` are both non-zero, `amount` of ``from``'s tokens\n     * will be to transferred to `to`.\n     * - when `from` is zero, `amount` tokens will be minted for `to`.\n     * - when `to` is zero, `amount` of ``from``'s tokens will be burned.\n     * - `from` and `to` are never both zero.\n     *\n     * To learn more about hooks, head to xref:ROOT:extending-contracts.adoc#using-hooks[Using Hooks].\n     */\n    function _beforeTokenTransfer(address from, address to, uint256 amount) internal virtual { }\n}\n"
    },
    "@openzeppelin/contracts/GSN/Context.sol": {
      "content": "pragma solidity ^0.6.0;\n\n/*\n * @dev Provides information about the current execution context, including the\n * sender of the transaction and its data. While these are generally available\n * via msg.sender and msg.data, they should not be accessed in such a direct\n * manner, since when dealing with GSN meta-transactions the account sending and\n * paying for execution may not be the actual sender (as far as an application\n * is concerned).\n *\n * This contract is only required for intermediate, library-like contracts.\n */\ncontract Context {\n    // Empty internal constructor, to prevent people from mistakenly deploying\n    // an instance of this contract, which should be used via inheritance.\n    constructor () internal { }\n\n    function _msgSender() internal view virtual returns (address payable) {\n        return msg.sender;\n    }\n\n    function _msgData() internal view virtual returns (bytes memory) {\n        this; // silence state mutability warning without generating bytecode - see https://github.com/ethereum/solidity/issues/2691\n        return msg.data;\n    }\n}\n"
    },
    "contracts/funding/test-fixtures/Echo.sol": {
      "content": "pragma solidity 0.6.7;\n\n\ncontract Echo {\n    address masterCopy;\n\n    function helloWorld() external pure returns (string memory) {\n        return \"hello world\";\n    }\n\n    function helloWorldArg(string calldata arg)\n        external\n        pure\n        returns (string memory)\n    {\n        return arg;\n    }\n\n    function msgSender() external view returns (address) {\n        return msg.sender;\n    }\n\n    function returnArg(bool arg) external pure returns (bool) {\n        return arg;\n    }\n}\n"
    },
    "contracts/funding/test-fixtures/FixedTwoPartyOutcomeApp.sol": {
      "content": "pragma solidity 0.6.7;\npragma experimental \"ABIEncoderV2\";\n\nimport \"../../adjudicator/interfaces/CounterfactualApp.sol\";\nimport \"../libs/LibOutcome.sol\";\n\n\ncontract TwoPartyFixedOutcomeApp is CounterfactualApp {\n\n    function computeOutcome(bytes calldata /* encodedState */)\n        override\n        external\n        view\n        returns (bytes memory)\n    {\n        return abi.encode(\n            LibOutcome.TwoPartyFixedOutcome.SPLIT_AND_SEND_TO_BOTH_ADDRS\n        );\n    }\n\n}\n"
    }
  },
  "settings": {
    "metadata": {
      "useLiteralContent": true
    },
    "optimizer": {
      "enabled": false,
      "runs": 200
    },
    "outputSelection": {
      "*": {
        "*": [
          "abi",
          "evm.bytecode",
          "evm.deployedBytecode",
          "evm.methodIdentifiers"
        ],
        "": [
          "id",
          "ast"
        ]
      }
    }
  }
}