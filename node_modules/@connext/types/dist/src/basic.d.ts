import * as ethers from "ethers";
import { providers, utils } from "ethers";
export { Contract } from "ethers";
export declare type JsonRpcProvider = providers.JsonRpcProvider;
export declare const JsonRpcProvider: typeof ethers.ethers.providers.JsonRpcProvider;
export declare type TransactionReceipt = providers.TransactionReceipt;
export declare type TransactionResponse = providers.TransactionResponse;
export declare type BigNumberish = ethers.BigNumberish;
export declare type Network = providers.Network;
export declare type Transaction = providers.TransactionRequest;
export declare type ABIEncoding = string;
export declare type Address = string;
export declare type AssetId = string;
export declare type Bytes32 = string;
export declare type DecString = string;
export declare type HexString = string;
export declare type PublicIdentifier = string;
export declare type PublicKey = string;
export declare type PrivateKey = string;
export declare type SignatureString = string;
export declare type UrlString = string;
export declare type BigNumber = ethers.BigNumber;
export declare const BigNumber: typeof ethers.ethers.BigNumber;
export declare type BigNumberJson = {
    _hex: HexString;
    _isBigNumber: true;
};
export declare type StringMapping = {
    [key: string]: string;
};
export interface EthSignature {
    r: string;
    s: string;
    v: string;
}
export declare type ContractABI = Array<string | utils.ParamType> | string | utils.Interface;
export declare type SolidityPrimitiveType = string | ethers.BigNumberish | boolean;
declare type SolidityABIEncoderV2Struct = {
    [x: string]: SolidityValueType;
};
declare type SolidityABIEncoderV2SArray = Array<SolidityValueType>;
export declare type SolidityValueType = SolidityPrimitiveType | SolidityABIEncoderV2Struct | SolidityABIEncoderV2SArray;
export declare type Omit<T, K extends keyof T> = Pick<T, Exclude<keyof T, K>>;
//# sourceMappingURL=basic.d.ts.map