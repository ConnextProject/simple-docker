import { EventNames, EventPayloads } from "./events";
import { Address, Bytes32, DecString, PublicIdentifier } from "./basic";
import { ILoggerService } from "./logger";
import { MethodResults, MethodParams } from "./methods";
import { ProtocolName, ProtocolParam } from "./protocol";
export declare type Message<T = any> = {
    data: T;
    from: Address;
    type: EventNames;
};
export declare type ProtocolMessageData = {
    processID: string;
    protocol: ProtocolName;
    params?: ProtocolParam;
    to: PublicIdentifier;
    seq: number;
    customData: {
        [key: string]: any;
    };
};
declare type ProposeInstallMessageData = {
    params: MethodParams.ProposeInstall;
    appIdentityHash: Bytes32;
};
export declare type CreateChannelMessage = Message<MethodResults.CreateChannel>;
export declare type DepositConfirmationMessage = Message<MethodParams.Deposit>;
export declare type DepositFailedMessage = Message<{
    params: MethodParams.Deposit;
    errors: string[];
}>;
export declare type DepositStartedMessage = Message<{
    value: DecString;
    txHash: Bytes32;
}>;
export declare type InstallMessage = Message<{
    params: MethodParams.Install;
}>;
export declare type ProtocolMessage = Message<ProtocolMessageData>;
export declare type ProposeMessage = Message<ProposeInstallMessageData>;
export declare type RejectProposalMessage = Message<{
    appIdentityHash: Bytes32;
}>;
export declare type SyncMessage = Message<EventPayloads.Sync>;
export declare type UninstallMessage = Message<EventPayloads.Uninstall>;
export declare type UpdateStateMessage = Message<EventPayloads.UpdateState>;
export interface MessagingConfig {
    clusterId?: string;
    logger?: ILoggerService;
    messagingUrl: string | string[];
    options?: any;
    privateKey?: string;
    publicKey?: string;
    token?: string;
}
export interface IMessagingService {
    connect(): Promise<void>;
    disconnect(): Promise<void>;
    flush(): Promise<void>;
    onReceive(subject: string, callback: (msg: Message) => void): Promise<void>;
    publish(subject: string, data: any): Promise<void>;
    request(subject: string, timeout: number, data: object, callback?: (response: any) => any): Promise<any>;
    send(to: string, msg: Message): Promise<void>;
    subscribe(subject: string, callback: (msg: Message) => void): Promise<void>;
    unsubscribe(subject: string): Promise<void>;
}
export {};
//# sourceMappingURL=messaging.d.ts.map