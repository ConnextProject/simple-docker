import { providers } from "ethers";
import { AppChallenge, ChallengeEvent, ChallengeEventData, ChallengeUpdatedEventPayload, NetworkContext, SignedCancelChallengeRequest, StateProgressedEventPayload, ChallengeEvents } from "./contracts";
import { StateChannelJSON } from "./state";
import { Address, Bytes32 } from "./basic";
import { AppInstanceJson } from "./app";
import { ConditionalTransactionCommitmentJSON, MinimalTransaction, SetStateCommitmentJSON } from "./commitments";
import { IChannelSigner } from "./crypto";
import { ILoggerService, ILogger } from "./logger";
export declare type WatcherInitOptions = {
    signer: IChannelSigner | string;
    provider: providers.JsonRpcProvider | string;
    context: NetworkContext;
    store: IWatcherStoreService;
    logger?: ILoggerService | ILogger;
    logLevel?: number;
};
declare type BaseChallengeTransactionCompletedEvent = {
    transaction: providers.TransactionReceipt;
    appInstanceId: Bytes32;
    multisigAddress: Address;
};
declare type BaseChallengeTransactionFailedEvent = {
    appInstanceId: Bytes32;
    error: string;
    multisigAddress: Address;
    challenge: StoredAppChallenge | undefined;
    params: any;
};
export declare const ChallengeProgressedEvent = "ChallengeProgressedEvent";
export declare type ChallengeProgressedEventData = BaseChallengeTransactionCompletedEvent;
export declare const ChallengeProgressionFailedEvent = "ChallengeProgressionFailedEvent";
export declare type ChallengeProgressionFailedEventData = BaseChallengeTransactionFailedEvent;
export declare const ChallengeCompletedEvent = "ChallengeCompletedEvent";
export declare type ChallengeCompletedEventData = BaseChallengeTransactionCompletedEvent;
export declare const ChallengeCompletionFailedEvent = "ChallengeCompletionFailedEvent";
export declare type ChallengeCompletionFailedEventData = BaseChallengeTransactionFailedEvent;
export declare const ChallengeOutcomeSetEvent = "ChallengeOutcomeSetEvent";
export declare type ChallengeOutcomeSetEventData = BaseChallengeTransactionCompletedEvent;
export declare const ChallengeOutcomeFailedEvent = "ChallengeOutcomeFailedEvent";
export declare type ChallengeOutcomeFailedEventData = BaseChallengeTransactionFailedEvent;
export declare const ChallengeCancelledEvent = "ChallengeCancelledEvent";
export declare type ChallengeCancelledEventData = BaseChallengeTransactionCompletedEvent;
export declare const ChallengeCancellationFailedEvent = "ChallengeCancellationFailedEvent";
export declare type ChallengeCancellationFailedEventData = BaseChallengeTransactionFailedEvent;
export declare const ChallengeUpdatedEvent = "ChallengeUpdatedEvent";
export declare type ChallengeUpdatedEventData = ChallengeEventData[typeof ChallengeEvents.ChallengeUpdated];
export declare const StateProgressedEvent = "StateProgressedEvent";
export declare type StateProgressedEventData = ChallengeEventData[typeof ChallengeEvents.StateProgressed];
export declare const WatcherEvents: {
    readonly ChallengeUpdatedEvent: "ChallengeUpdatedEvent";
    readonly StateProgressedEvent: "StateProgressedEvent";
    readonly ChallengeProgressedEvent: "ChallengeProgressedEvent";
    readonly ChallengeProgressionFailedEvent: "ChallengeProgressionFailedEvent";
    readonly ChallengeOutcomeSetEvent: "ChallengeOutcomeSetEvent";
    readonly ChallengeOutcomeFailedEvent: "ChallengeOutcomeFailedEvent";
    readonly ChallengeCompletedEvent: "ChallengeCompletedEvent";
    readonly ChallengeCompletionFailedEvent: "ChallengeCompletionFailedEvent";
    readonly ChallengeCancelledEvent: "ChallengeCancelledEvent";
    readonly ChallengeCancellationFailedEvent: "ChallengeCancellationFailedEvent";
};
export declare type WatcherEvent = keyof typeof WatcherEvents;
interface WatcherEventDataMap {
    [ChallengeUpdatedEvent]: ChallengeUpdatedEventData;
    [StateProgressedEvent]: StateProgressedEventData;
    [ChallengeProgressedEvent]: ChallengeProgressedEventData;
    [ChallengeProgressionFailedEvent]: ChallengeProgressionFailedEventData;
    [ChallengeOutcomeFailedEvent]: ChallengeOutcomeFailedEventData;
    [ChallengeOutcomeSetEvent]: ChallengeOutcomeSetEventData;
    [ChallengeCompletedEvent]: ChallengeCompletedEventData;
    [ChallengeCompletionFailedEvent]: ChallengeCompletionFailedEventData;
    [ChallengeCancelledEvent]: ChallengeCancelledEventData;
    [ChallengeCancellationFailedEvent]: ChallengeCancellationFailedEventData;
}
export declare type WatcherEventData = {
    [P in keyof WatcherEventDataMap]: WatcherEventDataMap[P];
};
export declare type ChallengeInitiatedResponse = {
    freeBalanceChallenge: providers.TransactionReceipt;
    appChallenge: providers.TransactionReceipt;
};
export interface IWatcher {
    emit<T extends WatcherEvent>(event: T, data: WatcherEventData[T]): void;
    on<T extends WatcherEvent>(event: T, callback: (data: WatcherEventData[T]) => Promise<void>): void;
    once<T extends WatcherEvent>(event: T, callback: (data: WatcherEventData[T]) => Promise<void>): void;
    removeListener<T extends WatcherEvent>(event: T): void;
    removeAllListeners(): void;
    enable(): Promise<void>;
    disable(): Promise<void>;
    initiate(appIdentityHash: string): Promise<ChallengeInitiatedResponse>;
    cancel(appIdentityHash: string, req: SignedCancelChallengeRequest): Promise<providers.TransactionReceipt>;
}
export interface IChainListener {
    emit<T extends ChallengeEvent>(event: T, data: ChallengeEventData[T]): void;
    on<T extends ChallengeEvent>(event: T, callback: (data: ChallengeEventData[T]) => Promise<void>): void;
    once<T extends ChallengeEvent>(event: T, callback: (data: ChallengeEventData[T]) => Promise<void>): void;
    removeListener<T extends ChallengeEvent>(event: T): void;
    removeAllListeners(): void;
    enable(): Promise<void>;
    disable(): Promise<void>;
    parseLogsFrom(startingBlock: number): Promise<void>;
}
export declare enum StoredAppChallengeStatus {
    NO_CHALLENGE = 0,
    IN_DISPUTE = 1,
    IN_ONCHAIN_PROGRESSION = 2,
    EXPLICITLY_FINALIZED = 3,
    OUTCOME_SET = 4,
    CONDITIONAL_SENT = 5,
    PENDING_TRANSITION = 6
}
export declare type StoredAppChallenge = Omit<AppChallenge, "status"> & {
    identityHash: Bytes32;
    status: StoredAppChallengeStatus;
};
export interface IWatcherStoreService {
    getAppChallenge(appIdentityHash: Bytes32): Promise<StoredAppChallenge | undefined>;
    saveAppChallenge(data: ChallengeUpdatedEventPayload | StoredAppChallenge): Promise<void>;
    getActiveChallenges(): Promise<StoredAppChallenge[]>;
    getLatestProcessedBlock(): Promise<number>;
    updateLatestProcessedBlock(blockNumber: number): Promise<void>;
    getStateProgressedEvents(appIdentityHash: Bytes32): Promise<StateProgressedEventPayload[]>;
    createStateProgressedEvent(event: StateProgressedEventPayload): Promise<void>;
    getChallengeUpdatedEvents(appIdentityHash: Bytes32): Promise<ChallengeUpdatedEventPayload[]>;
    createChallengeUpdatedEvent(event: ChallengeUpdatedEventPayload): Promise<void>;
    addOnchainAction(appIdentityHash: Bytes32, provider: providers.JsonRpcProvider): Promise<void>;
    getSchemaVersion(): Promise<number>;
    getAllChannels(): Promise<StateChannelJSON[]>;
    getStateChannel(multisigAddress: Address): Promise<StateChannelJSON | undefined>;
    getStateChannelByOwners(owners: Address[]): Promise<StateChannelJSON | undefined>;
    getStateChannelByAppIdentityHash(appIdentityHash: Bytes32): Promise<StateChannelJSON | undefined>;
    getAppInstance(appIdentityHash: Bytes32): Promise<AppInstanceJson | undefined>;
    getAppProposal(appIdentityHash: Bytes32): Promise<AppInstanceJson | undefined>;
    getFreeBalance(multisigAddress: Address): Promise<AppInstanceJson | undefined>;
    getSetupCommitment(multisigAddress: Address): Promise<MinimalTransaction | undefined>;
    getSetStateCommitments(appIdentityHash: Bytes32): Promise<SetStateCommitmentJSON[]>;
    getConditionalTransactionCommitment(appIdentityHash: Bytes32): Promise<ConditionalTransactionCommitmentJSON | undefined>;
}
export {};
//# sourceMappingURL=watcher.d.ts.map