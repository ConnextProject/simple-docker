"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.computeAppChallengeHash = exports.appStateToHash = exports.computeCancelDisputeHash = exports.appIdentityToHash = void 0;
const ethers_1 = require("ethers");
const types_1 = require("@connext/types");
const limitedCache_1 = require("./limitedCache");
const { solidityPack, keccak256 } = ethers_1.utils;
const appIdentityCache = new limitedCache_1.LimitedCache(50);
exports.appIdentityToHash = (appIdentity) => {
    const key = `${appIdentity.multisigAddress}${appIdentity.channelNonce}${appIdentity.participants.join("")}${appIdentity.appDefinition}${appIdentity.defaultTimeout}`;
    const cached = appIdentityCache.get(key);
    if (cached) {
        return cached;
    }
    const res = keccak256(solidityPack(["address", "uint256", "bytes32", "address", "uint256"], [
        appIdentity.multisigAddress,
        appIdentity.channelNonce,
        keccak256(solidityPack(["address[]"], [appIdentity.participants])),
        appIdentity.appDefinition,
        appIdentity.defaultTimeout,
    ]));
    appIdentityCache.set(key, res);
    return res;
};
exports.computeCancelDisputeHash = (identityHash, versionNumber) => keccak256(solidityPack(["uint8", "bytes32", "uint256"], [types_1.CommitmentTarget.CANCEL_DISPUTE, identityHash, versionNumber]));
exports.appStateToHash = (state) => keccak256(state);
exports.computeAppChallengeHash = (id, appStateHash, versionNumber, timeout) => keccak256(solidityPack(["uint8", "bytes32", "bytes32", "uint256", "uint256"], [types_1.CommitmentTarget.SET_STATE, id, appStateHash, versionNumber, timeout]));
//# sourceMappingURL=contracts.js.map