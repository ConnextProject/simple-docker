"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const node_1 = require("./lib/node");
const secp256k1_1 = require("./lib/secp256k1");
const elliptic_1 = require("./lib/elliptic");
const validators_1 = require("./helpers/validators");
const constants_1 = require("./helpers/constants");
function generatePrivate() {
    return node_1.isNode() ? secp256k1_1.secp256k1GeneratePrivate() : elliptic_1.ellipticGeneratePrivate();
}
exports.generatePrivate = generatePrivate;
function checkPrivateKey(privateKey) {
    validators_1.assert(privateKey.length === constants_1.KEY_LENGTH, 'Bad private key');
    validators_1.assert(validators_1.isValidPrivateKey(privateKey), 'Bad private key');
}
exports.checkPrivateKey = checkPrivateKey;
function checkPublicKey(publicKey) {
    validators_1.assert(publicKey.length === constants_1.PREFIXED_DECOMPRESSED_LENGTH ||
        publicKey.length === constants_1.PREFIXED_KEY_LENGTH, 'Bad public key');
    if (publicKey.length === constants_1.PREFIXED_DECOMPRESSED_LENGTH) {
        validators_1.assert(publicKey[0] === 4, 'Bad public key');
    }
    if (publicKey.length === constants_1.PREFIXED_KEY_LENGTH) {
        validators_1.assert(publicKey[0] === 2 || publicKey[0] === 3, 'Bad public key');
    }
}
exports.checkPublicKey = checkPublicKey;
function checkMessage(msg) {
    validators_1.assert(msg.length > 0, 'Message should not be empty');
    validators_1.assert(msg.length <= constants_1.MAX_MSG_LENGTH, 'Message is too long');
}
exports.checkMessage = checkMessage;
function compress(publicKey) {
    return node_1.isNode() ? secp256k1_1.secp256k1Compress(publicKey) : elliptic_1.ellipticCompress(publicKey);
}
exports.compress = compress;
function decompress(publicKey) {
    return node_1.isNode()
        ? secp256k1_1.secp256k1Decompress(publicKey)
        : elliptic_1.ellipticDecompress(publicKey);
}
exports.decompress = decompress;
function getPublic(privateKey) {
    checkPrivateKey(privateKey);
    return node_1.isNode()
        ? secp256k1_1.secp256k1GetPublic(privateKey)
        : elliptic_1.ellipticGetPublic(privateKey);
}
exports.getPublic = getPublic;
function getPublicCompressed(privateKey) {
    checkPrivateKey(privateKey);
    return node_1.isNode()
        ? secp256k1_1.secp256k1GetPublicCompressed(privateKey)
        : elliptic_1.ellipticGetPublicCompressed(privateKey);
}
exports.getPublicCompressed = getPublicCompressed;
function generateKeyPair() {
    const privateKey = generatePrivate();
    const publicKey = getPublic(privateKey);
    return { privateKey, publicKey };
}
exports.generateKeyPair = generateKeyPair;
function signatureExport(sig) {
    return node_1.isNode()
        ? secp256k1_1.secp256k1SignatureExport(sig)
        : elliptic_1.ellipticSignatureExport(sig);
}
exports.signatureExport = signatureExport;
function sign(privateKey, msg, rsvSig = false) {
    return __awaiter(this, void 0, void 0, function* () {
        checkPrivateKey(privateKey);
        checkMessage(msg);
        return node_1.isNode()
            ? secp256k1_1.secp256k1Sign(msg, privateKey, rsvSig)
            : elliptic_1.ellipticSign(msg, privateKey, rsvSig);
    });
}
exports.sign = sign;
function recover(msg, sig, compressed = false) {
    return __awaiter(this, void 0, void 0, function* () {
        checkMessage(msg);
        return node_1.isNode()
            ? secp256k1_1.secp256k1Recover(sig, msg, compressed)
            : elliptic_1.ellipticRecover(sig, msg, compressed);
    });
}
exports.recover = recover;
function verify(publicKey, msg, sig) {
    return __awaiter(this, void 0, void 0, function* () {
        checkPublicKey(publicKey);
        checkMessage(msg);
        const sigGood = node_1.isNode()
            ? secp256k1_1.secp256k1Verify(sig, msg, publicKey)
            : elliptic_1.ellipticVerify(sig, msg, publicKey);
        if (sigGood) {
            return null;
        }
        else {
            throw new Error('Bad signature');
        }
    });
}
exports.verify = verify;
//# sourceMappingURL=ecdsa.js.map