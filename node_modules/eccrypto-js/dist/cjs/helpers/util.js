"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const constants_1 = require("./constants");
function removeHexPrefix(hex) {
    return hex.replace(/^0x/, '');
}
exports.removeHexPrefix = removeHexPrefix;
function addHexPrefix(hex) {
    return hex.startsWith('0x') ? hex : `0x${hex}`;
}
exports.addHexPrefix = addHexPrefix;
function utf8ToBuffer(utf8) {
    return Buffer.from(utf8, constants_1.UTF8_ENC);
}
exports.utf8ToBuffer = utf8ToBuffer;
function hexToBuffer(hex) {
    return Buffer.from(removeHexPrefix(hex), constants_1.HEX_ENC);
}
exports.hexToBuffer = hexToBuffer;
function arrayToBuffer(arr) {
    return Buffer.from(arr);
}
exports.arrayToBuffer = arrayToBuffer;
function bufferToUtf8(buf) {
    return buf.toString(constants_1.UTF8_ENC);
}
exports.bufferToUtf8 = bufferToUtf8;
function bufferToHex(buf, prefixed = false) {
    const hex = buf.toString(constants_1.HEX_ENC);
    return prefixed ? addHexPrefix(hex) : hex;
}
exports.bufferToHex = bufferToHex;
function bufferToArray(buf) {
    return new Uint8Array(buf);
}
exports.bufferToArray = bufferToArray;
function hexToUtf8(hex) {
    return bufferToUtf8(hexToBuffer(hex));
}
exports.hexToUtf8 = hexToUtf8;
function utf8ToHex(utf8, prefixed = false) {
    return bufferToHex(utf8ToBuffer(utf8), prefixed);
}
exports.utf8ToHex = utf8ToHex;
function numberToHex(num, prefixed = false) {
    const hex = num.toString(16);
    return prefixed ? addHexPrefix(hex) : hex;
}
exports.numberToHex = numberToHex;
function hexToNumber(hex) {
    return parseInt(hex, 16);
}
exports.hexToNumber = hexToNumber;
function bufferToNumber(buf) {
    return hexToNumber(bufferToHex(buf));
}
exports.bufferToNumber = bufferToNumber;
function numberToBuffer(num) {
    return hexToBuffer(numberToHex(num));
}
exports.numberToBuffer = numberToBuffer;
function concatBuffers(...args) {
    const result = Buffer.concat(args);
    return result;
}
exports.concatBuffers = concatBuffers;
function trimLeft(data, length) {
    const diff = data.length - length;
    if (diff > 0) {
        data = data.slice(diff);
    }
    return data;
}
exports.trimLeft = trimLeft;
function trimRight(data, length) {
    return data.slice(0, length);
}
exports.trimRight = trimRight;
function padString(str, length, left, padding = '0') {
    const diff = length - str.length;
    let result = str;
    if (diff > 0) {
        const pad = padding.repeat(diff);
        result = left ? pad + str : str + pad;
    }
    return result;
}
exports.padString = padString;
function padLeft(str, length, padding = '0') {
    return padString(str, length, true, padding);
}
exports.padLeft = padLeft;
function padRight(str, length, padding = '0') {
    return padString(str, length, false, padding);
}
exports.padRight = padRight;
function isCompressed(publicKey) {
    return (publicKey.length === constants_1.KEY_LENGTH || publicKey.length === constants_1.PREFIXED_KEY_LENGTH);
}
exports.isCompressed = isCompressed;
function isDecompressed(publicKey) {
    return (publicKey.length === constants_1.DECOMPRESSED_LENGTH ||
        publicKey.length === constants_1.PREFIXED_DECOMPRESSED_LENGTH);
}
exports.isDecompressed = isDecompressed;
function isPrefixed(publicKey) {
    if (isCompressed(publicKey)) {
        return publicKey.length === constants_1.PREFIXED_KEY_LENGTH;
    }
    return publicKey.length === constants_1.PREFIXED_DECOMPRESSED_LENGTH;
}
exports.isPrefixed = isPrefixed;
function sanitizePublicKey(publicKey) {
    return isPrefixed(publicKey)
        ? publicKey
        : Buffer.from(`04${publicKey.toString('hex')}`, 'hex');
}
exports.sanitizePublicKey = sanitizePublicKey;
function exportRecoveryParam(recoveryParam) {
    return numberToBuffer(recoveryParam + 27);
}
exports.exportRecoveryParam = exportRecoveryParam;
function importRecoveryParam(v) {
    return bufferToNumber(v) - 27;
}
exports.importRecoveryParam = importRecoveryParam;
function splitSignature(sig) {
    return {
        r: sig.slice(0, 32),
        s: sig.slice(32, 64),
        v: sig.slice(64, 65),
    };
}
exports.splitSignature = splitSignature;
function joinSignature(sig) {
    return concatBuffers(sig.r, sig.s, sig.v);
}
exports.joinSignature = joinSignature;
function isValidDERSignature(sig) {
    return bufferToHex(sig).startsWith('30') && sig.length > 65;
}
exports.isValidDERSignature = isValidDERSignature;
function sanitizeRSVSignature(sig) {
    return {
        signature: sig.slice(0, 64),
        recovery: importRecoveryParam(sig.slice(64, 65)),
    };
}
exports.sanitizeRSVSignature = sanitizeRSVSignature;
//# sourceMappingURL=util.js.map